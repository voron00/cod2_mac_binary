/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'Call of Duty 2 Multiplayer'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct _RuneEntry;
struct _RuneCharClass;
struct TXNATSUIFeatures;
struct TXNATSUIVariations;
struct UnsignedWide;
struct QElem;
union ParamBlockRec;
struct _opaque_pthread_mutexattr_t;
struct MD4state_st;
struct gclient_s;
struct archivedEntity_s;
struct cmodel_s;
struct clientInfo_t;
struct tagInfo_s;
struct cachedSnapshot_s;

/* 1 */
struct IUnknown_vtbl_layout
{
  __int32 thisOffset;
  void *rtti;
  HRESULT (__cdecl *QueryInterface)(IUnknown *__hidden this, REFIID iid, LPVOID *ppv);
  ULONG (__cdecl *AddRef)(IUnknown *__hidden this);
  ULONG (__cdecl *Release)(IUnknown *__hidden this);
};

/* 3 */
typedef unsigned int uint32_t;

/* 5 */
typedef int integer_t;

/* 4 */
typedef integer_t cpu_type_t;

/* 6 */
typedef integer_t cpu_subtype_t;

/* 2 */
struct mach_header
{
  uint32_t magic;
  cpu_type_t cputype;
  cpu_subtype_t cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
};

/* 9 */
typedef float CGFloat;

/* 8 */
struct CGPoint
{
  CGFloat x;
  CGFloat y;
};

/* 10 */
struct CGSize
{
  CGFloat width;
  CGFloat height;
};

/* 7 */
struct CGRect
{
  CGPoint origin;
  CGSize size;
};

/* 14 */
typedef int __darwin_wchar_t;

/* 13 */
typedef __darwin_wchar_t __darwin_rune_t;

/* 12 */
typedef unsigned __int32 __darwin_size_t;

/* 15 */
typedef unsigned int __uint32_t;

/* 16 */
struct _RuneRange
{
  int __nranges;
  _RuneEntry *__ranges;
};

/* 11 */
struct _RuneLocale
{
  char __magic[8];
  char __encoding[32];
  __darwin_rune_t (__cdecl *__sgetrune)(const char *, __darwin_size_t, const char **);
  int (__cdecl *__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
  __darwin_rune_t __invalid_rune;
  __uint32_t __runetype[256];
  __darwin_rune_t __maplower[256];
  __darwin_rune_t __mapupper[256];
  _RuneRange __runetype_ext;
  _RuneRange __maplower_ext;
  _RuneRange __mapupper_ext;
  void *__variable;
  int __variable_len;
  int __ncharclasses;
  _RuneCharClass *__charclasses;
};

/* 17 */
struct _RuneEntry
{
  __darwin_rune_t __min;
  __darwin_rune_t __max;
  __darwin_rune_t __map;
  __uint32_t *__types;
};

/* 18 */
struct _RuneCharClass
{
  char __name[14];
  __uint32_t __mask;
};

/* 20 */
typedef unsigned __int32 UInt32;

/* 33 */
struct __CFURL;

/* 32 */
typedef const struct __CFURL *CFURLRef;

/* 19 */
#pragma pack(push, 2)
union TXNAttributeData
{
  void *dataPtr;
  UInt32 dataValue;
  TXNATSUIFeatures *atsuFeatures;
  TXNATSUIVariations *atsuVariations;
  CFURLRef urlReference;
};
#pragma pack(pop)

/* 22 */
typedef unsigned __int32 ItemCount;

/* 24 */
typedef unsigned __int16 UInt16;

/* 23 */
typedef UInt16 ATSUFontFeatureType;

/* 25 */
typedef UInt16 ATSUFontFeatureSelector;

/* 21 */
#pragma pack(push, 2)
struct TXNATSUIFeatures
{
  ItemCount featureCount;
  ATSUFontFeatureType *featureTypes;
  ATSUFontFeatureSelector *featureSelectors;
};
#pragma pack(pop)

/* 28 */
typedef UInt32 FourCharCode;

/* 27 */
typedef FourCharCode ATSUFontVariationAxis;

/* 31 */
typedef __int32 SInt32;

/* 30 */
typedef SInt32 Fixed;

/* 29 */
typedef Fixed ATSUFontVariationValue;

/* 26 */
#pragma pack(push, 2)
struct TXNATSUIVariations
{
  ItemCount variationCount;
  ATSUFontVariationAxis *variationAxis;
  ATSUFontVariationValue *variationValues;
};
#pragma pack(pop)

/* 35 */
enum _CGLRendererProperty : unsigned __int32
{
  kCGLRPOffScreen = 0x35,
  kCGLRPRendererID = 0x46,
  kCGLRPAccelerated = 0x49,
  kCGLRPBackingStore = 0x4C,
  kCGLRPWindow = 0x50,
  kCGLRPCompliant = 0x53,
  kCGLRPDisplayMask = 0x54,
  kCGLRPBufferModes = 0x64,
  kCGLRPColorModes = 0x67,
  kCGLRPAccumModes = 0x68,
  kCGLRPDepthModes = 0x69,
  kCGLRPStencilModes = 0x6A,
  kCGLRPMaxAuxBuffers = 0x6B,
  kCGLRPMaxSampleBuffers = 0x6C,
  kCGLRPMaxSamples = 0x6D,
  kCGLRPSampleModes = 0x6E,
  kCGLRPSampleAlpha = 0x6F,
  kCGLRPGPUVertProcCapable = 0x7A,
  kCGLRPGPUFragProcCapable = 0x7B,
  kCGLRPRendererCount = 0x80,
  kCGLRPOnline = 0x81,
  kCGLRPAcceleratedCompute = 0x82,
  kCGLRPVideoMemoryMegabytes = 0x83,
  kCGLRPTextureMemoryMegabytes = 0x84,
  kCGLRPMajorGLVersion = 0x85,
  kCGLRPRegistryIDLow = 0x8C,
  kCGLRPRegistryIDHigh = 0x8D,
  kCGLRPRemovable = 0x8E,
  kCGLRPRobust = 0x4B,
  kCGLRPMPSafe = 0x4E,
  kCGLRPMultiScreen = 0x51,
  kCGLRPFullScreen = 0x36,
  kCGLRPVideoMemory = 0x78,
  kCGLRPTextureMemory = 0x79,
};

/* 34 */
typedef _CGLRendererProperty CGLRendererProperty;

/* 36 */
enum CFNumberType : __int32
{
  kCFNumberSInt8Type = 0x1,
  kCFNumberSInt16Type = 0x2,
  kCFNumberSInt32Type = 0x3,
  kCFNumberSInt64Type = 0x4,
  kCFNumberFloat32Type = 0x5,
  kCFNumberFloat64Type = 0x6,
  kCFNumberCharType = 0x7,
  kCFNumberShortType = 0x8,
  kCFNumberIntType = 0x9,
  kCFNumberLongType = 0xA,
  kCFNumberLongLongType = 0xB,
  kCFNumberFloatType = 0xC,
  kCFNumberDoubleType = 0xD,
  kCFNumberCFIndexType = 0xE,
  kCFNumberNSIntegerType = 0xF,
  kCFNumberCGFloatType = 0x10,
  kCFNumberMaxType = 0x10,
};

/* 37 */
typedef UnsignedWide AbsoluteTime;

/* 38 */
#pragma pack(push, 2)
struct UnsignedWide
{
  UInt32 lo;
  UInt32 hi;
};
#pragma pack(pop)

/* 39 */
#pragma pack(push, 8)
struct LONG_DOUBLE_16
{
  _TBYTE value;
  char padding[6];
};
#pragma pack(pop)

/* 40 */
enum CGColorRenderingIntent : __int32
{
  kCGRenderingIntentDefault = 0x0,
  kCGRenderingIntentAbsoluteColorimetric = 0x1,
  kCGRenderingIntentRelativeColorimetric = 0x2,
  kCGRenderingIntentPerceptual = 0x3,
  kCGRenderingIntentSaturation = 0x4,
};

/* 42 */
typedef int vm_prot_t;

/* 41 */
#pragma pack(push, 8)
struct __attribute__((aligned(4))) segment_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint32_t vmaddr;
  uint32_t vmsize;
  uint32_t fileoff;
  uint32_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};
#pragma pack(pop)

/* 43 */
#pragma pack(push, 8)
struct __attribute__((aligned(4))) section
{
  char sectname[16];
  char segname[16];
  uint32_t addr;
  uint32_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
};
#pragma pack(pop)

/* 45 */
union lc_str
{
  uint32_t offset;
  char *ptr;
};

/* 44 */
struct dylinker_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  lc_str name;
};

/* 47 */
struct dylib
{
  lc_str name;
  uint32_t timestamp;
  uint32_t current_version;
  uint32_t compatibility_version;
};

/* 46 */
struct dylib_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  dylib dylib;
};

/* 48 */
struct symtab_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t symoff;
  uint32_t nsyms;
  uint32_t stroff;
  uint32_t strsize;
};

/* 49 */
struct dysymtab_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t ilocalsym;
  uint32_t nlocalsym;
  uint32_t iextdefsym;
  uint32_t nextdefsym;
  uint32_t iundefsym;
  uint32_t nundefsym;
  uint32_t tocoff;
  uint32_t ntoc;
  uint32_t modtaboff;
  uint32_t nmodtab;
  uint32_t extrefsymoff;
  uint32_t nextrefsyms;
  uint32_t indirectsymoff;
  uint32_t nindirectsyms;
  uint32_t extreloff;
  uint32_t nextrel;
  uint32_t locreloff;
  uint32_t nlocrel;
};

/* 50 */
struct twolevel_hints_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t offset;
  uint32_t nhints;
};

/* 51 */
struct __CFString
{
  void *isa;
  __int32 info;
  char *data;
  __int32 length;
};

/* 52 */
typedef signed __int32 _Unwind_Sword;

/* 53 */
typedef unsigned __int32 _Unwind_Ptr;

/* 54 */
typedef unsigned __int32 _Unwind_Internal_Ptr;

/* 55 */
typedef unsigned __int32 _Unwind_Word;

/* 56 */
typedef int _Unwind_Action;

/* 57 */
typedef unsigned __int64 _Unwind_Exception_Class;

/* 58 */
enum $BDF88968CAE1EA74E42809B9AE857E7C
{
  _URC_NO_REASON = 0x0,
  _URC_FOREIGN_EXCEPTION_CAUGHT = 0x1,
  _URC_FATAL_PHASE2_ERROR = 0x2,
  _URC_FATAL_PHASE1_ERROR = 0x3,
  _URC_NORMAL_STOP = 0x4,
  _URC_END_OF_STACK = 0x5,
  _URC_HANDLER_FOUND = 0x6,
  _URC_INSTALL_CONTEXT = 0x7,
  _URC_CONTINUE_UNWIND = 0x8,
};

/* 59 */
typedef void (__cdecl *_Unwind_Exception_Cleanup_Fn)(_Unwind_Reason_Code, struct _Unwind_Exception *);

/* 60 */
typedef _Unwind_Reason_Code (__cdecl *_Unwind_Personality_Fn)(int, _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *, struct _Unwind_Context *);

/* 61 */
typedef _Unwind_Reason_Code (__cdecl *_Unwind_Stop_Fn)(int, _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *, struct _Unwind_Context *, void *);

/* 62 */
typedef _Unwind_Sword __guard;

/* 63 */
struct type_info;

/* 64 */
struct __class_type_info;

/* 67 */
typedef FourCharCode ResType;

/* 66 */
typedef ResType DescType;

/* 70 */
struct OpaqueAEDataStorageType;

/* 69 */
typedef struct OpaqueAEDataStorageType *AEDataStorageType;

/* 68 */
typedef AEDataStorageType *AEDataStorage;

/* 65 */
#pragma pack(push, 2)
struct AEDesc
{
  DescType descriptorType;
  AEDataStorage dataHandle;
};
#pragma pack(pop)

/* 73 */
typedef AEDesc AEDescList;

/* 72 */
typedef AEDescList AERecord;

/* 71 */
typedef AERecord AppleEvent;

/* 74 */
#pragma pack(push, 2)
struct Rect
{
  __int16 top;
  __int16 left;
  __int16 bottom;
  __int16 right;
};
#pragma pack(pop)

/* 76 */
typedef FourCharCode OSType;

/* 75 */
#pragma pack(push, 2)
struct EventTypeSpec
{
  OSType eventClass;
  UInt32 eventKind;
};
#pragma pack(pop)

/* 77 */
typedef CGSize HISize;

/* 78 */
#pragma pack(push, 2)
struct ControlID
{
  OSType signature;
  SInt32 id;
};
#pragma pack(pop)

/* 79 */
#pragma pack(push, 2)
struct ControlKind
{
  OSType signature;
  OSType kind;
};
#pragma pack(pop)

/* 80 */
#pragma pack(push, 2)
struct Point
{
  __int16 v;
  __int16 h;
};
#pragma pack(pop)

/* 81 */
#pragma pack(push, 2)
struct RGBColor
{
  unsigned __int16 red;
  unsigned __int16 green;
  unsigned __int16 blue;
};
#pragma pack(pop)

/* 83 */
typedef unsigned __int8 UInt8;

/* 82 */
#pragma pack(push, 2)
struct FSRef
{
  UInt8 hidden[80];
};
#pragma pack(pop)

/* 85 */
enum _CGLPixelFormatAttribute : unsigned __int32
{
  kCGLPFAAllRenderers = 0x1,
  kCGLPFATripleBuffer = 0x3,
  kCGLPFADoubleBuffer = 0x5,
  kCGLPFAColorSize = 0x8,
  kCGLPFAAlphaSize = 0xB,
  kCGLPFADepthSize = 0xC,
  kCGLPFAStencilSize = 0xD,
  kCGLPFAMinimumPolicy = 0x33,
  kCGLPFAMaximumPolicy = 0x34,
  kCGLPFASampleBuffers = 0x37,
  kCGLPFASamples = 0x38,
  kCGLPFAColorFloat = 0x3A,
  kCGLPFAMultisample = 0x3B,
  kCGLPFASupersample = 0x3C,
  kCGLPFASampleAlpha = 0x3D,
  kCGLPFARendererID = 0x46,
  kCGLPFANoRecovery = 0x48,
  kCGLPFAAccelerated = 0x49,
  kCGLPFAClosestPolicy = 0x4A,
  kCGLPFABackingStore = 0x4C,
  kCGLPFABackingVolatile = 0x4D,
  kCGLPFADisplayMask = 0x54,
  kCGLPFAAllowOfflineRenderers = 0x60,
  kCGLPFAAcceleratedCompute = 0x61,
  kCGLPFAOpenGLProfile = 0x63,
  kCGLPFASupportsAutomaticGraphicsSwitching = 0x65,
  kCGLPFAVirtualScreenCount = 0x80,
  kCGLPFAAuxBuffers = 0x7,
  kCGLPFAAccumSize = 0xE,
  kCGLPFAAuxDepthStencil = 0x39,
  kCGLPFAStereo = 0x6,
  kCGLPFAOffScreen = 0x35,
  kCGLPFAWindow = 0x50,
  kCGLPFACompliant = 0x53,
  kCGLPFAPBuffer = 0x5A,
  kCGLPFARemotePBuffer = 0x5B,
  kCGLPFASingleRenderer = 0x47,
  kCGLPFARobust = 0x4B,
  kCGLPFAMPSafe = 0x4E,
  kCGLPFAMultiScreen = 0x51,
  kCGLPFAFullScreen = 0x36,
};

/* 84 */
typedef _CGLPixelFormatAttribute CGLPixelFormatAttribute;

/* 88 */
typedef __int16 SInt16;

/* 87 */
typedef SInt16 FSVolumeRefNum;

/* 89 */
#pragma pack(push, 2)
struct UTCDateTime
{
  UInt16 highSeconds;
  UInt32 lowSeconds;
  UInt16 fraction;
};
#pragma pack(pop)

/* 90 */
typedef unsigned __int64 UInt64;

/* 91 */
typedef UInt32 TextEncoding;

/* 86 */
#pragma pack(push, 2)
struct FSCatalogInfo
{
  UInt16 nodeFlags;
  FSVolumeRefNum volume;
  UInt32 parentDirID;
  UInt32 nodeID;
  UInt8 sharingFlags;
  UInt8 userPrivileges;
  UInt8 reserved1;
  UInt8 reserved2;
  UTCDateTime createDate;
  UTCDateTime contentModDate;
  UTCDateTime attributeModDate;
  UTCDateTime accessDate;
  UTCDateTime backupDate;
  UInt32 permissions[4];
  UInt8 finderInfo[16];
  UInt8 extFinderInfo[16];
  UInt64 dataLogicalSize;
  UInt64 dataPhysicalSize;
  UInt64 rsrcLogicalSize;
  UInt64 rsrcPhysicalSize;
  UInt32 valence;
  TextEncoding textEncodingHint;
};
#pragma pack(pop)

/* 92 */
#pragma pack(push, 2)
struct ProcessSerialNumber
{
  UInt32 highLongOfPSN;
  UInt32 lowLongOfPSN;
};
#pragma pack(pop)

/* 95 */
typedef QElem *QElemPtr;

/* 97 */
typedef char *Ptr;

/* 100 */
typedef ParamBlockRec *ParmBlkPtr;

/* 99 */
typedef void (__cdecl *IOCompletionProcPtr)(ParmBlkPtr);

/* 98 */
typedef IOCompletionProcPtr IOCompletionUPP;

/* 103 */
typedef SInt16 OSErr;

/* 104 */
typedef unsigned __int8 *StringPtr;

/* 105 */
typedef SInt16 FSIORefNum;

/* 106 */
typedef char SInt8;

/* 108 */
#pragma pack(push, 2)
struct FInfo
{
  OSType fdType;
  OSType fdCreator;
  UInt16 fdFlags;
  Point fdLocation;
  SInt16 fdFldr;
};
#pragma pack(pop)

/* 113 */
#pragma pack(push, 2)
struct FXInfo
{
  SInt16 fdIconID;
  SInt16 fdReserved[3];
  SInt8 fdScript;
  SInt8 fdXFlags;
  SInt16 fdComment;
  SInt32 fdPutAway;
};
#pragma pack(pop)

/* 94 */
#pragma pack(push, 2)
struct HFileInfo
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioFRefNum;
  SInt8 ioFVersNum;
  SInt8 filler1;
  SInt16 ioFDirIndex;
  SInt8 ioFlAttrib;
  SInt8 ioACUser;
  FInfo ioFlFndrInfo;
  SInt32 ioDirID;
  UInt16 ioFlStBlk;
  SInt32 ioFlLgLen;
  SInt32 ioFlPyLen;
  UInt16 ioFlRStBlk;
  SInt32 ioFlRLgLen;
  SInt32 ioFlRPyLen;
  UInt32 ioFlCrDat;
  UInt32 ioFlMdDat;
  UInt32 ioFlBkDat;
  FXInfo ioFlXFndrInfo;
  SInt32 ioFlParID;
  SInt32 ioFlClpSiz;
};
#pragma pack(pop)

/* 115 */
#pragma pack(push, 2)
struct DInfo
{
  Rect frRect;
  UInt16 frFlags;
  Point frLocation;
  SInt16 frView;
};
#pragma pack(pop)

/* 116 */
#pragma pack(push, 2)
struct DXInfo
{
  Point frScroll;
  SInt32 frOpenChain;
  SInt8 frScript;
  SInt8 frXFlags;
  SInt16 frComment;
  SInt32 frPutAway;
};
#pragma pack(pop)

/* 114 */
#pragma pack(push, 2)
struct DirInfo
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioFRefNum;
  SInt8 ioFVersNum;
  SInt8 filler1;
  SInt16 ioFDirIndex;
  SInt8 ioFlAttrib;
  SInt8 ioACUser;
  DInfo ioDrUsrWds;
  SInt32 ioDrDirID;
  UInt16 ioDrNmFls;
  SInt16 filler3[9];
  UInt32 ioDrCrDat;
  UInt32 ioDrMdDat;
  UInt32 ioDrBkDat;
  DXInfo ioDrFndrInfo;
  SInt32 ioDrParID;
};
#pragma pack(pop)

/* 93 */
#pragma pack(push, 2)
union CInfoPBRec
{
  HFileInfo hFileInfo;
  DirInfo dirInfo;
};
#pragma pack(pop)

/* 96 */
#pragma pack(push, 2)
struct QElem
{
  QElem *qLink;
  __int16 qType;
  __int16 qData[1];
};
#pragma pack(pop)

/* 102 */
#pragma pack(push, 2)
struct IOParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioRefNum;
  SInt8 ioVersNum;
  SInt8 ioPermssn;
  Ptr ioMisc;
  Ptr ioBuffer;
  SInt32 ioReqCount;
  SInt32 ioActCount;
  SInt16 ioPosMode;
  SInt32 ioPosOffset;
};
#pragma pack(pop)

/* 107 */
#pragma pack(push, 2)
struct FileParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioFRefNum;
  SInt8 ioFVersNum;
  SInt8 filler1;
  SInt16 ioFDirIndex;
  SInt8 ioFlAttrib;
  SInt8 ioFlVersNum;
  FInfo ioFlFndrInfo;
  UInt32 ioFlNum;
  UInt16 ioFlStBlk;
  SInt32 ioFlLgLen;
  SInt32 ioFlPyLen;
  UInt16 ioFlRStBlk;
  SInt32 ioFlRLgLen;
  SInt32 ioFlRPyLen;
  UInt32 ioFlCrDat;
  UInt32 ioFlMdDat;
};
#pragma pack(pop)

/* 109 */
#pragma pack(push, 2)
struct VolumeParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  UInt32 filler2;
  SInt16 ioVolIndex;
  UInt32 ioVCrDate;
  UInt32 ioVLsBkUp;
  UInt16 ioVAtrb;
  UInt16 ioVNmFls;
  UInt16 ioVDirSt;
  SInt16 ioVBlLn;
  UInt16 ioVNmAlBlks;
  UInt32 ioVAlBlkSiz;
  UInt32 ioVClpSiz;
  UInt16 ioAlBlSt;
  UInt32 ioVNxtFNum;
  UInt16 ioVFrBlk;
};
#pragma pack(pop)

/* 110 */
#pragma pack(push, 2)
struct CntrlParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioCRefNum;
  SInt16 csCode;
  SInt16 csParam[11];
};
#pragma pack(pop)

/* 111 */
#pragma pack(push, 2)
struct SlotDevParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioSRefNum;
  SInt8 ioSVersNum;
  SInt8 ioSPermssn;
  Ptr ioSMix;
  SInt16 ioSFlags;
  SInt8 ioSlot;
  SInt8 ioID;
};
#pragma pack(pop)

/* 112 */
#pragma pack(push, 2)
struct MultiDevParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioMRefNum;
  SInt8 ioMVersNum;
  SInt8 ioMPermssn;
  Ptr ioMMix;
  SInt16 ioMFlags;
  Ptr ioSEBlkPtr;
};
#pragma pack(pop)

/* 101 */
#pragma pack(push, 2)
union ParamBlockRec
{
  IOParam ioParam;
  FileParam fileParam;
  VolumeParam volumeParam;
  CntrlParam cntrlParam;
  SlotDevParam slotDevParam;
  MultiDevParam multiDevParam;
};
#pragma pack(pop)

/* 119 */
typedef unsigned __int8 Str63[64];

/* 118 */
typedef Str63 StrFileName;

/* 117 */
#pragma pack(push, 2)
struct FSSpec
{
  FSVolumeRefNum vRefNum;
  SInt32 parID;
  StrFileName name;
};
#pragma pack(pop)

/* 121 */
typedef UInt16 EventKind;

/* 122 */
typedef UInt16 EventModifiers;

/* 120 */
#pragma pack(push, 2)
struct EventRecord
{
  EventKind what;
  unsigned __int32 message;
  UInt32 when;
  Point where;
  EventModifiers modifiers;
};
#pragma pack(pop)

/* 123 */
#pragma pack(push, 2)
struct FSVolumeInfo
{
  UTCDateTime createDate;
  UTCDateTime modifyDate;
  UTCDateTime backupDate;
  UTCDateTime checkedDate;
  UInt32 fileCount;
  UInt32 folderCount;
  UInt64 totalBytes;
  UInt64 freeBytes;
  UInt32 blockSize;
  UInt32 totalBlocks;
  UInt32 freeBlocks;
  UInt32 nextAllocation;
  UInt32 rsrcClumpSize;
  UInt32 dataClumpSize;
  UInt32 nextCatalogID;
  UInt8 finderInfo[32];
  UInt16 flags;
  UInt16 filesystemID;
  UInt16 signature;
  UInt16 driveNumber;
  FSIORefNum driverRefNum;
};
#pragma pack(pop)

/* 125 */
typedef unsigned __int16 u_int16_t;

/* 124 */
struct __attribute__((packed)) __attribute__((aligned(2))) HFSUniStr255
{
  u_int16_t length;
  u_int16_t unicode[255];
};

/* 127 */
#pragma pack(push, 2)
struct HIOParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioRefNum;
  SInt8 ioVersNum;
  SInt8 ioPermssn;
  Ptr ioMisc;
  Ptr ioBuffer;
  SInt32 ioReqCount;
  SInt32 ioActCount;
  SInt16 ioPosMode;
  SInt32 ioPosOffset;
};
#pragma pack(pop)

/* 128 */
#pragma pack(push, 2)
struct HFileParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioFRefNum;
  SInt8 ioFVersNum;
  SInt8 filler1;
  SInt16 ioFDirIndex;
  SInt8 ioFlAttrib;
  SInt8 ioFlVersNum;
  FInfo ioFlFndrInfo;
  SInt32 ioDirID;
  UInt16 ioFlStBlk;
  SInt32 ioFlLgLen;
  SInt32 ioFlPyLen;
  UInt16 ioFlRStBlk;
  SInt32 ioFlRLgLen;
  SInt32 ioFlRPyLen;
  UInt32 ioFlCrDat;
  UInt32 ioFlMdDat;
};
#pragma pack(pop)

/* 129 */
#pragma pack(push, 2)
struct HVolumeParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  SInt32 filler2;
  SInt16 ioVolIndex;
  UInt32 ioVCrDate;
  UInt32 ioVLsMod;
  SInt16 ioVAtrb;
  UInt16 ioVNmFls;
  UInt16 ioVBitMap;
  UInt16 ioAllocPtr;
  UInt16 ioVNmAlBlks;
  UInt32 ioVAlBlkSiz;
  UInt32 ioVClpSiz;
  UInt16 ioAlBlSt;
  UInt32 ioVNxtCNID;
  UInt16 ioVFrBlk;
  UInt16 ioVSigWord;
  SInt16 ioVDrvInfo;
  FSIORefNum ioVDRefNum;
  SInt16 ioVFSID;
  UInt32 ioVBkUp;
  SInt16 ioVSeqNum;
  UInt32 ioVWrCnt;
  UInt32 ioVFilCnt;
  UInt32 ioVDirCnt;
  SInt32 ioVFndrInfo[8];
};
#pragma pack(pop)

/* 130 */
#pragma pack(push, 2)
struct AccessParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSIORefNum ioRefNum;
  SInt16 ioDenyModes;
  SInt16 filler4;
  SInt8 filler5;
  SInt8 ioACUser;
  SInt32 filler6;
  SInt32 ioACOwnerID;
  SInt32 ioACGroupID;
  SInt32 ioACAccess;
  SInt32 ioDirID;
};
#pragma pack(pop)

/* 131 */
#pragma pack(push, 2)
struct ObjParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  SInt16 filler7;
  SInt16 ioObjType;
  StringPtr ioObjNamePtr;
  SInt32 ioObjID;
};
#pragma pack(pop)

/* 132 */
#pragma pack(push, 2)
struct CopyParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSVolumeRefNum ioDstVRefNum;
  SInt16 filler8;
  StringPtr ioNewName;
  StringPtr ioCopyName;
  SInt32 ioNewDirID;
  SInt32 filler14;
  SInt32 filler15;
  SInt32 ioDirID;
};
#pragma pack(pop)

/* 133 */
#pragma pack(push, 2)
struct WDParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  SInt16 ioWDCreated;
  SInt16 ioWDIndex;
  SInt32 ioWDProcID;
  FSVolumeRefNum ioWDVRefNum;
  SInt16 filler10;
  SInt32 filler11;
  SInt32 filler12;
  SInt32 filler13;
  SInt32 ioWDDirID;
};
#pragma pack(pop)

/* 134 */
#pragma pack(push, 2)
struct FIDParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  SInt32 filler14;
  StringPtr ioDestNamePtr;
  SInt32 filler15;
  SInt32 ioDestDirID;
  SInt32 filler16;
  SInt32 filler17;
  SInt32 ioSrcDirID;
  SInt16 filler18;
  SInt32 ioFileID;
};
#pragma pack(pop)

/* 136 */
typedef FSSpec *FSSpecPtr;

/* 137 */
typedef CInfoPBRec *CInfoPBPtr;

/* 138 */
#pragma pack(push, 2)
struct CatPositionRec
{
  SInt32 initialize;
  SInt16 priv[6];
};
#pragma pack(pop)

/* 135 */
#pragma pack(push, 2)
struct CSParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  FSSpecPtr ioMatchPtr;
  SInt32 ioReqMatchCount;
  SInt32 ioActMatchCount;
  SInt32 ioSearchBits;
  CInfoPBPtr ioSearchInfo1;
  CInfoPBPtr ioSearchInfo2;
  SInt32 ioSearchTime;
  CatPositionRec ioCatPosition;
  Ptr ioOptBuffer;
  SInt32 ioOptBufSize;
};
#pragma pack(pop)

/* 139 */
#pragma pack(push, 2)
struct ForeignPrivParam
{
  QElemPtr qLink;
  SInt16 qType;
  SInt16 ioTrap;
  Ptr ioCmdAddr;
  IOCompletionUPP ioCompletion;
  OSErr ioResult;
  StringPtr ioNamePtr;
  FSVolumeRefNum ioVRefNum;
  SInt32 ioFiller21;
  SInt32 ioFiller22;
  Ptr ioForeignPrivBuffer;
  SInt32 ioForeignPrivActCount;
  SInt32 ioForeignPrivReqCount;
  SInt32 ioFiller23;
  SInt32 ioForeignPrivDirID;
  SInt32 ioForeignPrivInfo1;
  SInt32 ioForeignPrivInfo2;
  SInt32 ioForeignPrivInfo3;
  SInt32 ioForeignPrivInfo4;
};
#pragma pack(pop)

/* 126 */
#pragma pack(push, 2)
union HParamBlockRec
{
  HIOParam ioParam;
  HFileParam fileParam;
  HVolumeParam volumeParam;
  AccessParam accessParam;
  ObjParam objParam;
  CopyParam copyParam;
  WDParam wdParam;
  FIDParam fidParam;
  CSParam csParam;
  ForeignPrivParam foreignPrivParam;
};
#pragma pack(pop)

/* 140 */
#pragma pack(push, 2)
struct ProcessInfoRec
{
  UInt32 processInfoLength;
  StringPtr processName;
  ProcessSerialNumber processNumber;
  UInt32 processType;
  OSType processSignature;
  UInt32 processMode;
  Ptr processLocation;
  UInt32 processSize;
  UInt32 processFreeMem;
  ProcessSerialNumber processLauncher;
  UInt32 processLaunchDate;
  UInt32 processActiveTime;
  FSSpecPtr processAppSpec;
};
#pragma pack(pop)

/* 142 */
typedef unsigned __int8 Boolean;

/* 143 */
typedef const __CFString *CFStringRef;

/* 144 */
typedef UInt32 OptionBits;

/* 146 */
struct OpaqueIconRef;

/* 145 */
typedef struct OpaqueIconRef *IconRef;

/* 141 */
#pragma pack(push, 2)
struct AlertStdCFStringAlertParamRec
{
  UInt32 version;
  Boolean movable;
  Boolean helpButton;
  CFStringRef defaultText;
  CFStringRef cancelText;
  CFStringRef otherText;
  SInt16 defaultButton;
  SInt16 cancelButton;
  UInt16 position;
  OptionBits flags;
  IconRef icon;
};
#pragma pack(pop)

/* 147 */
struct sched_param
{
  int sched_priority;
  char __opaque[4];
};

/* 150 */
typedef unsigned __int64 __uint64_t;

/* 149 */
typedef __uint64_t rlim_t;

/* 148 */
struct rlimit
{
  rlim_t rlim_cur;
  rlim_t rlim_max;
};

/* 154 */
typedef int __int32_t;

/* 153 */
typedef __int32_t __darwin_dev_t;

/* 152 */
typedef __darwin_dev_t dev_t;

/* 157 */
typedef unsigned __int16 __uint16_t;

/* 156 */
typedef __uint16_t __darwin_mode_t;

/* 155 */
typedef __darwin_mode_t mode_t;

/* 158 */
typedef __uint16_t nlink_t;

/* 159 */
typedef __uint64_t __darwin_ino64_t;

/* 161 */
typedef __uint32_t __darwin_uid_t;

/* 160 */
typedef __darwin_uid_t uid_t;

/* 163 */
typedef __uint32_t __darwin_gid_t;

/* 162 */
typedef __darwin_gid_t gid_t;

/* 165 */
typedef __int32 __darwin_time_t;

/* 164 */
struct timespec
{
  __darwin_time_t tv_sec;
  __int32 tv_nsec;
};

/* 168 */
typedef __int64 __int64_t;

/* 167 */
typedef __int64_t __darwin_off_t;

/* 166 */
typedef __darwin_off_t off_t;

/* 170 */
typedef __int64_t __darwin_blkcnt_t;

/* 169 */
typedef __darwin_blkcnt_t blkcnt_t;

/* 172 */
typedef __int32_t __darwin_blksize_t;

/* 171 */
typedef __darwin_blksize_t blksize_t;

/* 151 */
struct stat
{
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  __darwin_ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  timespec st_atimespec;
  timespec st_mtimespec;
  timespec st_ctimespec;
  timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 174 */
typedef double Float64;

/* 175 */
typedef UInt32 AudioFormatID;

/* 176 */
typedef UInt32 AudioFormatFlags;

/* 173 */
struct AudioStreamBasicDescription
{
  Float64 mSampleRate;
  AudioFormatID mFormatID;
  AudioFormatFlags mFormatFlags;
  UInt32 mBytesPerPacket;
  UInt32 mFramesPerPacket;
  UInt32 mBytesPerFrame;
  UInt32 mChannelsPerFrame;
  UInt32 mBitsPerChannel;
  UInt32 mReserved;
};

/* 177 */
#pragma pack(push, 2)
struct ComponentDescription
{
  OSType componentType;
  OSType componentSubType;
  OSType componentManufacturer;
  UInt32 componentFlags;
  UInt32 componentFlagsMask;
};
#pragma pack(pop)

/* 179 */
typedef _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;

/* 178 */
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;

/* 180 */
struct _opaque_pthread_mutexattr_t
{
  __int32 __sig;
  char __opaque[8];
};

/* 182 */
typedef __int32_t __darwin_suseconds_t;

/* 181 */
struct timeval
{
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};

/* 184 */
typedef unsigned __int8 __uint8_t;

/* 185 */
typedef __uint8_t sa_family_t;

/* 183 */
struct sockaddr
{
  __uint8_t sa_len;
  sa_family_t sa_family;
  char sa_data[14];
};

/* 187 */
struct AudioBuffer
{
  UInt32 mNumberChannels;
  UInt32 mDataByteSize;
  void *mData;
};

/* 186 */
struct AudioBufferList
{
  UInt32 mNumberBuffers;
  AudioBuffer mBuffers[1];
};

/* 188 */
struct CAEEvent;

/* 189 */
struct CAETarget;

/* 190 */
struct CAEDesc;

/* 191 */
struct CAEObject;

/* 192 */
struct CAERecord;

/* 193 */
struct MacBuilder;

/* 194 */
struct MacDisplay;

/* 195 */
struct OpaqueContextRef;

/* 196 */
struct MacFeatures;

/* 197 */
struct MacFiles;

/* 198 */
struct MacFolders;

/* 199 */
struct MacGlobals;

/* 200 */
struct MacPreferences;

/* 201 */
struct MacResources;

/* 202 */
struct MacStrings;

/* 203 */
struct MacTools;

/* 204 */
struct StdConverterARGB;

/* 205 */
struct StdConverterABGR;

/* 206 */
struct ATI4CompsConverterARGB;

/* 207 */
struct ATI4CompsConverterABGR;

/* 208 */
struct CDirect3D;

/* 209 */
struct CDirect3DDevice;

/* 210 */
struct CDirect3DDevice::CTexStage;

/* 211 */
struct CDirect3DIndexBuffer;

/* 212 */
struct CDirect3DPixelShader;

/* 213 */
struct COpenGLATITextFragmentShader;

/* 214 */
struct COpenGLNVidiaRegisterCombinersProgram;

/* 215 */
struct COpenGLARBFragmentProgram;

/* 216 */
struct CDirect3DSurface;

/* 217 */
struct CDirect3DSwapChain;

/* 218 */
struct CDirect3DTexture;

/* 219 */
struct CDirect3DVertexBuffer;

/* 220 */
struct CStaticCacheInfo;

/* 221 */
struct CDirect3DVertexDeclaration;

/* 222 */
struct CDirect3DVertexShader;

/* 223 */
struct COpenGL;

/* 224 */
struct COpenGLMatrix;

/* 225 */
struct MacOpenGLUtils;

/* 226 */
struct CMacGameEngine;

/* 227 */
struct LargeLocal;

/* 228 */
struct CStringEdPackage;

/* 229 */
struct MediaHandles;

/* 230 */
struct FxRange;

/* 231 */
struct PrimitiveTemplate;

/* 232 */
struct FxScheduler;

/* 233 */
struct Effect;

/* 234 */
struct Particle;

/* 235 */
struct OrientedParticle;

/* 236 */
struct Cloud;

/* 237 */
struct Line;

/* 238 */
struct Tail;

/* 239 */
struct Cylinder;

/* 240 */
struct Emitter;

/* 241 */
struct Light;

/* 242 */
struct Flash;

/* 243 */
struct FxArchive;

/* 244 */
struct FxHelper;

/* 245 */
struct GPValue;

/* 246 */
struct GPGroup;

/* 247 */
struct GenericParser2;

/* 248 */
typedef MD4state_st MD4_CTX;

/* 249 */
struct MD4state_st
{
  unsigned int A;
  unsigned int B;
  unsigned int C;
  unsigned int D;
  unsigned int Nl;
  unsigned int Nh;
  unsigned int data[16];
  unsigned int num;
};

/* 250 */
struct IncludeClass;

/* 251 */
struct CCallOfDutyEngine;

/* 252 */
struct COpenGLVAO;

/* 253 */
struct CBaseVA;

/* 254 */
struct CTexCoordArray;

/* 255 */
struct CColorArray;

/* 256 */
struct CNormalArray;

/* 257 */
struct CVertexArray;

/* 258 */
struct CVAOPacket;

/* 259 */
struct CAStreamBasicDescription;

/* 260 */
struct CSampleSound;

/* 261 */
struct CSoundEngine;

/* 262 */
struct CMutex;

/* 263 */
struct CThread;

/* 264 */
struct StMutexLock;

/* 265 */
struct StThreadLock;

/* 266 */
struct CDirect3DVolume;

/* 267 */
struct CDirect3DVolumeTexture;

/* 268 */
struct CD3DXBuffer;

/* 269 */
struct CD3DXConstantTable;

/* 270 */
struct CSoundObject;

/* 271 */
struct CAudioRecorder;

/* 272 */
struct CCircularBuffer;

/* 273 */
struct CColorConverter;

/* 274 */
struct CVAOPacketFixedFunction;

/* 275 */
struct CVAOPacketProgrammable;

/* 276 */
struct COpenGLTexture;

/* 277 */
struct CDirect3DCubeTexture;

/* 278 */
struct CCacheInfoBlock;

/* 279 */
struct CSecondaryColorArray;

/* 280 */
struct std::string;

/* 281 */
struct std::_List_node_base;

/* 282 */
struct StPortState;

/* 283 */
struct StShowCursor;

/* 284 */
struct WinIcon;

/* 285 */
struct WinCursor;

/* 286 */
struct CFence;

/* 287 */
struct CMemoryBuffer;

/* 288 */
struct COpenGL::CTexUnit;

/* 289 */
struct COpenGLVertexProgram;

/* 290 */
struct FxBoltFrame;

/* 291 */
struct CStreamSound;

/* 292 */
struct ScheduledEffect;

/* 293 */
struct FxBoltFramePtr;

/* 294 */
#pragma pack(push, 8)
struct msg_t
{
  int overflowed;
  byte *data;
  int maxsize;
  int cursize;
  int readcount;
  int bit;
};
#pragma pack(pop)

/* 295 */
#pragma pack(push, 8)
struct ucolor_t
{
  int i;
  byte rgba[4];
};
#pragma pack(pop)

/* 296 */
typedef float vec_t;

/* 297 */
typedef vec_t vec2_t[2];

/* 298 */
typedef vec_t vec3_t[3];

/* 299 */
typedef vec_t vec4_t[4];

/* 300 */
union DvarValue
{
  bool boolean;
  int integer;
  float decimal;
  char *string;
};

/* 301 */
enum DvarSetSource
{
  DVAR_SOURCE_INTERNAL = 0x0,
  DVAR_SOURCE_EXTERNAL = 0x1,
  DVAR_SOURCE_SCRIPT = 0x2,
};

/* 302 */
#pragma pack(push, 8)
struct dvarlimits_enum
{
  int stringCount;
  const char **strings;
};
#pragma pack(pop)

/* 303 */
#pragma pack(push, 8)
struct dvarlimits_integer
{
  int min;
  int max;
};
#pragma pack(pop)

/* 304 */
#pragma pack(push, 8)
struct dvarlimits_decimal
{
  float min;
  float max;
};
#pragma pack(pop)

/* 305 */
#pragma pack(push, 8)
struct DvarLimits
{
  dvarlimits_enum enumeration;
  dvarlimits_integer integer;
  dvarlimits_decimal decimal;
};
#pragma pack(pop)

/* 306 */
enum DvarType : __int8
{
  DVAR_BOOL = 0x0,
  DVAR_FLOAT = 0x1,
  DVAR_VEC2 = 0x2,
  DVAR_VEC3 = 0x3,
  DVAR_VEC4 = 0x4,
  DVAR_INT = 0x5,
  DVAR_ENUM = 0x6,
  DVAR_STRING = 0x7,
  DVAR_COLOR = 0x8,
};

/* 307 */
#pragma pack(push, 8)
struct dvar_s
{
  const char *name;
  unsigned __int16 flags;
  char type;
  byte modified;
  DvarValue current;
  DvarValue latched;
  DvarValue reset;
  DvarLimits domain;
  struct dvar_s *next;
  struct dvar_s *hashNext;
};
#pragma pack(pop)

/* 308 */
#pragma pack(push, 8)
struct scrVarPub_s
{
  const char *fieldBuffer;
  struct HunkUser *programHunkUser;
  u_int16_t canonicalStrCount;
  byte developer;
  byte developer_script;
  byte evaluate;
  byte pad[3];
  const char *error_message;
  int error_index;
  unsigned int time;
  unsigned int timeArrayId;
  unsigned int pauseArrayId;
  unsigned int levelId;
  unsigned int gameId;
  unsigned int animId;
  unsigned int freeEntList;
  unsigned int tempVariable;
  byte bInited;
  byte pad2;
  u_int16_t savecount;
  unsigned int checksum;
  unsigned int entId;
  unsigned int entFieldName;
  const char *programBuffer;
  const char *endScriptBuffer;
};
#pragma pack(pop)

/* 309 */
enum trType_t
{
  TR_STATIONARY = 0x0,
  TR_INTERPOLATE = 0x1,
  TR_LINEAR = 0x2,
  TR_LINEAR_STOP = 0x3,
  TR_SINE = 0x4,
  TR_GRAVITY = 0x5,
  TR_GRAVITY_PAUSED = 0x6,
  TR_ACCELERATE = 0x7,
  TR_DECCELERATE = 0x8,
};

/* 310 */
#pragma pack(push, 8)
struct trajectory_t
{
  int trType;
  int trTime;
  int trDuration;
  vec3_t trBase;
  vec3_t trDelta;
};
#pragma pack(pop)

/* 311 */
#pragma pack(push, 8)
struct entityState_s
{
  int number;
  int eType;
  int eFlags;
  trajectory_t pos;
  trajectory_t apos;
  int time;
  int time2;
  vec3_t origin2;
  vec3_t angles2;
  int otherEntityNum;
  int attackerEntityNum;
  int groundEntityNum;
  int constantLight;
  int loopSound;
  int surfType;
  int index;
  int clientNum;
  int iHeadIcon;
  int iHeadIconTeam;
  int solid;
  int eventParm;
  int eventSequence;
  int events[4];
  int eventParms[4];
  int weapon;
  int legsAnim;
  int torsoAnim;
  float leanf;
  float scale;
  int dmgFlags;
  int animMovetype;
  float fTorsoHeight;
  float fTorsoPitch;
  float fWaistPitch;
};
#pragma pack(pop)

/* 312 */
#pragma pack(push, 8)
struct entityShared_s
{
  byte linked;
  byte bmodel;
  byte svFlags;
  byte pad1;
  int clientMask[2];
  byte inuse;
  byte pad2[3];
  int broadcastTime;
  vec3_t mins;
  vec3_t maxs;
  int contents;
  vec3_t absmin;
  vec3_t absmax;
  vec3_t currentOrigin;
  vec3_t currentAngles;
  u_int16_t ownerNum;
  u_int16_t pad3;
  int eventTime;
};
#pragma pack(pop)

/* 313 */
enum statIndex_t
{
  STAT_HEALTH = 0x0,
  STAT_DEAD_YAW = 0x1,
  STAT_MAX_HEALTH = 0x2,
  STAT_FRIENDLY_LOOKAT_CLIENTNUM = 0x3,
  STAT_FRIENDLY_LOOKAT_HEALTH = 0x4,
  STAT_SPAWN_COUNT = 0x5,
};

/* 314 */
enum ViewLockTypes_t
{
  PLAYERVIEWLOCK_NONE = 0x0,
  PLAYERVIEWLOCK_FULL = 0x1,
  PLAYERVIEWLOCK_WEAPONJITTER = 0x2,
  PLAYERVIEWLOCKCOUNT = 0x3,
};

/* 315 */
enum objectiveState_t
{
  OBJST_EMPTY = 0x0,
  OBJST_ACTIVE = 0x1,
  OBJST_INVISIBLE = 0x2,
  OBJST_DONE = 0x3,
  OBJST_CURRENT = 0x4,
  OBJST_FAILED = 0x5,
  OBJST_NUMSTATES = 0x6,
};

/* 316 */
#pragma pack(push, 8)
struct objective_t
{
  int state;
  vec3_t origin;
  int entNum;
  int teamNum;
  int icon;
};
#pragma pack(pop)

/* 317 */
enum he_type_t
{
  HE_TYPE_FREE = 0x0,
  HE_TYPE_TEXT = 0x1,
  HE_TYPE_VALUE = 0x2,
  HE_TYPE_PLAYERNAME = 0x3,
  HE_TYPE_MAPNAME = 0x4,
  HE_TYPE_GAMETYPE = 0x5,
  HE_TYPE_MATERIAL = 0x6,
  HE_TYPE_TIMER_DOWN = 0x7,
  HE_TYPE_TIMER_UP = 0x8,
  HE_TYPE_TENTHS_TIMER_DOWN = 0x9,
  HE_TYPE_TENTHS_TIMER_UP = 0xA,
  HE_TYPE_CLOCK_DOWN = 0xB,
  HE_TYPE_CLOCK_UP = 0xC,
  HE_TYPE_WAYPOINT = 0xD,
  HE_TYPE_COUNT = 0xE,
};

/* 318 */
#pragma pack(push, 8)
struct hudelem_colorsplit_t
{
  char r;
  char g;
  char b;
  char a;
};
#pragma pack(pop)

/* 319 */
#pragma pack(push, 8)
union hudelem_color_t
{
  hudelem_colorsplit_t split;
  int rgba;
};
#pragma pack(pop)

/* 320 */
#pragma pack(push, 8)
struct hudelem_s
{
  int type;
  float x;
  float y;
  float z;
  float fontScale;
  int font;
  int alignOrg;
  int alignScreen;
  hudelem_color_t color;
  hudelem_color_t fromColor;
  int fadeStartTime;
  int fadeTime;
  int label;
  int width;
  int height;
  int materialIndex;
  int fromWidth;
  int fromHeight;
  int scaleStartTime;
  int scaleTime;
  float fromX;
  float fromY;
  int fromAlignOrg;
  int fromAlignScreen;
  int moveStartTime;
  int moveTime;
  int time;
  int duration;
  float value;
  int text;
  float sort;
  hudelem_color_t foreground;
};
#pragma pack(pop)

/* 321 */
#pragma pack(push, 8)
struct turretInfo_s
{
  int inuse;
  int flags;
  int fireTime;
  vec2_t arcmin;
  vec2_t arcmax;
  float dropPitch;
  int stance;
  int prevStance;
  int fireSndDelay;
  vec3_t userOrigin;
  float playerSpread;
  int triggerDown;
  char fireSnd;
  char fireSndPlayer;
  char stopSnd;
  char stopSndPlayer;
};
#pragma pack(pop)

/* 445 */
#pragma pack(push, 8)
struct item_ent_t
{
  int ammoCount;
  int clipAmmoCount;
  int index;
};
#pragma pack(pop)

/* 444 */
#pragma pack(push, 8)
struct trigger_ent_t
{
  int threshold;
  int accumulate;
  int timestamp;
  int singleUserEntIndex;
  byte requireLookAt;
};
#pragma pack(pop)

/* 446 */
#pragma pack(push, 8)
struct mover_ent_t
{
  float decelTime;
  float aDecelTime;
  float speed;
  float aSpeed;
  float midTime;
  float aMidTime;
  vec3_t pos1;
  vec3_t pos2;
  vec3_t pos3;
  vec3_t apos1;
  vec3_t apos2;
  vec3_t apos3;
};
#pragma pack(pop)

/* 447 */
#pragma pack(push, 8)
struct corpse_ent_t
{
  int deathAnimStartTime;
};
#pragma pack(pop)

/* 450 */
#pragma pack(push, 8)
struct missile_ent_t
{
  float time;
  int timeOfBirth;
  float travelDist;
  vec3_t surfaceNormal;
  int team;
  vec3_t curvature;
  int targetEntNum;
  vec3_t targetOffset;
  int stage;
  int flightMode;
};
#pragma pack(pop)

/* 443 */
#pragma pack(push, 8)
union DynEntity
{
  struct item_ent_t item[2];
  struct trigger_ent_t trigger;
  struct mover_ent_t mover;
  struct corpse_ent_t corpse;
  struct missile_ent_t missile;
};
#pragma pack(pop)

/* 322 */
#pragma pack(push, 8)
struct gentity_s
{
  entityState_s s;
  entityShared_s r;
  struct gclient_s *client;
  turretInfo_s *pTurretInfo;
  byte physicsObject;
  byte takedamage;
  byte active;
  byte nopickup;
  byte model;
  byte dobjbits;
  byte handler;
  byte team;
  u_int16_t classname;
  u_int16_t target;
  u_int16_t targetname;
  u_int16_t padding;
  int spawnflags;
  int flags;
  int eventTime;
  int freeAfterEvent;
  int unlinkAfterEvent;
  int clipmask;
  int framenum;
  gentity_s *parent;
  int nextthink;
  int healthPoints;
  int reservedHealth;
  int damage;
  int count;
  int unknown;
  DynEntity params;
  tagInfo_s *tagInfo;
  gentity_s *tagChildren;
  u_int16_t attachModelNames[6];
  u_int16_t attachTagNames[6];
  int useCount;
  gentity_s *nextFree;
};
#pragma pack(pop)

/* 334 */
#pragma pack(push, 8)
struct mantleState_t
{
  float yaw;
  int timer;
  int transIndex;
  int flags;
};
#pragma pack(pop)

/* 335 */
#pragma pack(push, 8)
struct hudElemState_t
{
  hudelem_s current[31];
  hudelem_s archival[31];
};
#pragma pack(pop)

/* 336 */
#pragma pack(push, 8)
struct playerState_s
{
  int commandTime;
  int pm_type;
  int bobCycle;
  int pm_flags;
  int pm_time;
  vec3_t origin;
  vec3_t velocity;
  vec2_t oldVelocity;
  int weaponTime;
  int weaponDelay;
  int grenadeTimeLeft;
  int weaponRestrictKickTime;
  int foliageSoundTime;
  int gravity;
  float leanf;
  int speed;
  vec3_t delta_angles;
  int groundEntityNum;
  vec3_t vLadderVec;
  int jumpTime;
  float jumpOriginZ;
  int legsTimer;
  int legsAnim;
  int torsoTimer;
  int torsoAnim;
  int legsAnimDuration;
  int torsoAnimDuration;
  int damageTimer;
  int damageDuration;
  int flinchYaw;
  int movementDir;
  int eFlags;
  int eventSequence;
  int events[4];
  int eventParms[4];
  int oldEventSequence;
  int clientNum;
  int offHandIndex;
  unsigned int weapon;
  int weaponstate;
  float fWeaponPosFrac;
  int adsDelayTime;
  int viewmodelIndex;
  vec3_t viewangles;
  int viewHeightTarget;
  float viewHeightCurrent;
  int viewHeightLerpTime;
  int viewHeightLerpTarget;
  int viewHeightLerpDown;
  float viewHeightLerpPosAdj;
  vec2_t viewAngleClampBase;
  vec2_t viewAngleClampRange;
  int damageEvent;
  int damageYaw;
  int damagePitch;
  int damageCount;
  int stats[3];
  int persistant[3];
  int ammo[128];
  int ammoclip[128];
  int weapons[2];
  int oldweapons[2];
  byte weaponslots[8];
  int weaponrechamber[2];
  int oldweaponrechamber[2];
  vec3_t mins;
  vec3_t maxs;
  float proneDirection;
  float proneDirectionPitch;
  float proneTorsoPitch;
  int viewlocked;
  int viewlocked_entNum;
  int cursorHint;
  int cursorHintString;
  int cursorHintEntIndex;
  int iCompassFriendInfo;
  float fTorsoHeight;
  float fTorsoPitch;
  float fWaistPitch;
  float holdBreathScale;
  int holdBreathTimer;
  mantleState_t mantleState;
  int entityEventSequence;
  int weapAnim;
  float aimSpreadScale;
  int shellshockIndex;
  int shellshockTime;
  int shellshockDuration;
  objective_t objective[16];
  int deltaTime;
  hudElemState_t hud;
};
#pragma pack(pop)

/* 328 */
#pragma pack(push, 8)
struct usercmd_s
{
  int serverTime;
  int buttons;
  byte weapon;
  byte offHandIndex;
  int angles[3];
  char forwardmove;
  char rightmove;
};
#pragma pack(pop)

/* 344 */
#pragma pack(push, 8)
struct clientState_s
{
  int clientIndex;
  int team;
  int modelindex;
  int attachModelIndex[6];
  int attachTagIndex[6];
  char name[32];
};
#pragma pack(pop)

/* 337 */
#pragma pack(push, 8)
struct clientSession_s
{
  int connectState;
  int forceSpectatorClient;
  int statusIcon;
  int archiveTime;
  int score;
  int deaths;
  u_int16_t scriptPersId;
  byte pad2;
  byte pad;
  int connected;
  usercmd_s cmd;
  usercmd_s oldcmd;
  int localClient;
  int predictItemPickup;
  char name[32];
  int maxHealth;
  int enterTime;
  int voteCount;
  int teamVoteCount;
  float unknown;
  int viewmodelIndex;
  int noSpectate;
  int teamInfo;
  clientState_s state;
  int psOffsetTime;
};
#pragma pack(pop)

/* 338 */
#pragma pack(push, 8)
struct gclient_s
{
  playerState_s ps;
  clientSession_s sess;
  int spectatorClient;
  int noclip;
  int ufo;
  int bFrozen;
  int lastCmdTime;
  int buttons;
  int oldbuttons;
  int latched_buttons;
  int buttonsSinceLastFrame;
  vec3_t oldOrigin;
  float fGunPitch;
  float fGunYaw;
  int damage_blood;
  vec3_t damage_from;
  int damage_fromWorld;
  int accurateCount;
  int accuracy_shots;
  int accuracy_hits;
  int inactivityTime;
  int inactivityWarning;
  int playerTalkTime;
  int rewardTime;
  float currentAimSpreadScale;
  int sniperRifleFiredTime;
  float sniperRifleMuzzleYaw;
  int unknownClientEndFrameVar;
  vec3_t unknownVector;
  gentity_s *lookAtEntity;
  int activateEntNumber;
  int activateTime;
  int nonPVSFriendlyEntNum;
  int pingPlayerTime;
  int damageFeedBackTime;
  vec2_t damageFeedBackDir;
  vec3_t swayViewAngles;
  vec3_t swayOffset;
  vec3_t swayAngles;
  vec3_t vLastMoveAng;
  vec3_t vGunOffset;
  vec3_t vGunSpeed;
  int vGunAngle[2];
  int lastServerTime;
  int lastActivateTime;
};
#pragma pack(pop)

/* 442 */
#pragma pack(push, 8)
struct tagInfo_s
{
  struct gentity_s *parent;
  struct gentity_s *next;
  uint16_t name;
  uint16_t pad;
  int index;
  float axis[4][3];
  float parentInvAxis[4][3];
};
#pragma pack(pop)

/* 323 */
#pragma pack(push, 8)
struct trace_t
{
  float fraction;
  vec3_t normal;
  int surfaceFlags;
  int contents;
  const char *material;
  int entityNum;
  byte unknown1;
  byte unknown2;
  byte unknown3;
  byte startsolid;
};
#pragma pack(pop)

/* 324 */
enum clientConnectState_t
{
  CS_FREE = 0x0,
  CS_ZOMBIE = 0x1,
  CS_CONNECTED = 0x2,
  CS_PRIMED = 0x3,
  CS_ACTIVE = 0x4,
};

/* 325 */
enum netsrc_t
{
  NS_CLIENT = 0x0,
  NS_SERVER = 0x1,
};

/* 326 */
enum netadrtype_t
{
  NA_BOT = 0x0,
  NA_BAD = 0x0,
  NA_LOOPBACK = 0x2,
  NA_BROADCAST = 0x3,
  NA_IP = 0x4,
  NA_IPX = 0x5,
  NA_BROADCAST_IPX = 0x6,
};

/* 327 */
#pragma pack(push, 8)
struct netadr_t
{
  int type;
  byte ip[4];
  unsigned __int16 port;
};
#pragma pack(pop)

/* 329 */
#pragma pack(push, 8)
struct netchan_t
{
  int outgoingSequence;
  int sock;
  int dropped;
  int incomingSequence;
  netadr_t remoteAddress;
  int qport;
  int fragmentSequence;
  int fragmentLength;
  byte fragmentBuffer[16384];
  int unsentFragments;
  int unsentFragmentStart;
  int unsentLength;
  byte unsentBuffer[16384];
  void *netProfile;
};
#pragma pack(pop)

/* 330 */
#pragma pack(push, 8)
struct pmove_t
{
  struct playerState_s *ps;
  usercmd_s cmd;
  usercmd_s oldcmd;
  int tracemask;
  int numtouch;
  int touchents[32];
  vec3_t mins;
  vec3_t maxs;
  float xyspeed;
  int proneChange;
  byte mantleStarted;
  vec3_t mantleEndPos;
  int mantleDuration;
};
#pragma pack(pop)

/* 331 */
#pragma pack(push, 8)
struct pml_t
{
  vec3_t forward;
  vec3_t right;
  vec3_t up;
  float frametime;
  int msec;
  int walking;
  int groundPlane;
  int almostGroundPlane;
  trace_t groundTrace;
  float impactSpeed;
  vec3_t previous_origin;
  vec3_t previous_velocity;
};
#pragma pack(pop)

/* 332 */
#pragma pack(push, 8)
struct reliableCommands_t
{
  char command[1024];
  int cmdTime;
  int cmdType;
};
#pragma pack(pop)

/* 333 */
#pragma pack(push, 8)
struct challenge_t
{
  netadr_t adr;
  int challenge;
  int time;
  int pingTime;
  int firstTime;
  int firstPing;
  int connected;
  int guid;
};
#pragma pack(pop)

/* 339 */
#pragma pack(push, 8)
struct clientSnapshot_s
{
  playerState_s ps;
  int num_entities;
  int num_clients;
  int first_entity;
  int first_client;
  unsigned int messageSent;
  unsigned int messageAcked;
  int messageSize;
};
#pragma pack(pop)

/* 340 */
#pragma pack(push, 1)
struct VoicePacket_t
{
  char num;
  char data[256];
  int dataLen;
};
#pragma pack(pop)

/* 341 */
#pragma pack(push, 8)
struct client_s
{
  int state;
  int delayed;
  const char *delayDropMsg;
  char userinfo[1024];
  reliableCommands_t reliableCommands[128];
  int reliableSequence;
  int reliableAcknowledge;
  int reliableSent;
  int messageAcknowledge;
  int gamestateMessageNum;
  int challenge;
  usercmd_s lastUsercmd;
  int lastClientCommand;
  char lastClientCommandString[1024];
  gentity_s *gentity;
  char name[32];
  char downloadName[64];
  int download;
  int downloadSize;
  int downloadCount;
  int downloadClientBlock;
  int downloadCurrentBlock;
  int downloadXmitBlock;
  unsigned __int8 *downloadBlocks[8];
  int downloadBlockSize[8];
  int downloadEOF;
  int downloadSendTime;
  int deltaMessage;
  int floodprotect;
  int lastPacketTime;
  int lastConnectTime;
  int nextSnapshotTime;
  int rateDelayed;
  int timeoutCount;
  clientSnapshot_s frames[32];
  int ping;
  int rate;
  int snapshotMsec;
  int pureAuthentic;
  netchan_t netchan;
  int guid;
  __int16 clscriptid;
  int bot;
  int serverId;
  VoicePacket_t voicedata[40];
  int unsentVoiceData;
  byte mutedClients[64];
  byte hasVoip;
};
#pragma pack(pop)

/* 342 */
#pragma pack(push, 8)
struct archivedSnapshot_s
{
  int start;
  int size;
};
#pragma pack(pop)

/* 343 */
#pragma pack(push, 8)
struct cachedClient_s
{
  int playerStateExists;
  clientState_s *cs;
  playerState_s *ps;
};
#pragma pack(pop)

/* 477 */
#pragma pack(push, 8)
struct tempban_t
{
  int guid;
  int time;
};
#pragma pack(pop)

/* 345 */
#pragma pack(push, 8)
struct serverStatic_t
{
  int initialized;
  int time;
  int snapFlagServerBit;
  client_s *clients;
  int numSnapshotEntities;
  int numSnapshotClients;
  int nextSnapshotEntities;
  int nextSnapshotClients;
  entityState_s *snapshotEntities;
  clientState_s *snapshotClients;
  int archivedSnapshotEnabled;
  int nextArchivedSnapshotFrames;
  archivedSnapshot_s *archivedSnapshotFrames;
  byte *archivedSnapshotBuffer;
  int nextArchivedSnapshotBuffer;
  int nextCachedSnapshotEntities;
  int nextCachedSnapshotClients;
  int nextCachedSnapshotFrames;
  archivedEntity_s *cachedSnapshotEntities;
  cachedClient_s *cachedSnapshotClients;
  cachedSnapshot_s *cachedSnapshotFrames;
  int nextHeartbeatTime;
  int nextStatusResponseTime;
  challenge_t challenges[1024];
  netadr_t redirectAddress;
  netadr_t authorizeAddress;
  void *netProfilingBuf;
  tempban_t bans[16];
};
#pragma pack(pop)

/* 353 */
#pragma pack(push, 8)
struct archivedEntityShared_s
{
  int svFlags;
  int clientMask[2];
  vec3_t absmin;
  vec3_t absmax;
};
#pragma pack(pop)

/* 354 */
#pragma pack(push, 8)
struct archivedEntity_s
{
  entityState_s s;
  archivedEntityShared_s r;
};
#pragma pack(pop)

/* 452 */
#pragma pack(push, 8)
struct cachedSnapshot_s
{
  int archivedFrame;
  int time;
  int num_entities;
  int first_entity;
  int num_clients;
  int first_client;
  int usesDelta;
};
#pragma pack(pop)

/* 346 */
#pragma pack(push, 8)
struct keyValueStr_t
{
  const char *key;
  const char *value;
};
#pragma pack(pop)

/* 347 */
#pragma pack(push, 8)
struct SpawnVar
{
  byte spawnVarsValid;
  int numSpawnVars;
  keyValueStr_t spawnVars[64];
  int numSpawnVarChars;
  char spawnVarChars[2048];
};
#pragma pack(pop)

/* 348 */
#pragma pack(push, 8)
struct trigger_info_t
{
  u_int16_t entnum;
  u_int16_t otherEntnum;
  int useCount;
  int otherUseCount;
};
#pragma pack(pop)

/* 349 */
enum team_t
{
  TEAM_FREE = 0x0,
  TEAM_RED = 0x1,
  TEAM_BLUE = 0x2,
  TEAM_SPEC = 0x3,
  TEAM_NUM_TEAMS = 0x4,
};

/* 350 */
#pragma pack(push, 8)
struct level_locals_t
{
  struct gclient_s *clients;
  struct gentity_s *gentities;
  int gentitySize;
  int num_entities;
  struct gentity_s *firstFreeEnt;
  struct gentity_s *lastFreeEnt;
  int logFile;
  int initializing;
  int clientIsSpawning;
  objective_t objectives[16];
  int maxclients;
  int framenum;
  int time;
  int previousTime;
  int frameTime;
  int startTime;
  int teamScores[4];
  int lastTeammateHealthTime;
  int bUpdateScoresForIntermission;
  int manualNameChange;
  int numConnectedClients;
  int sortedClients[64];
  char voteString[1024];
  char voteDisplayString[1024];
  int voteTime;
  int voteExecuteTime;
  int voteYes;
  int voteNo;
  int numVotingClients;
  byte gap[2072];
  SpawnVar spawnVars;
  int savePersist;
  struct gentity_s *droppedWeaponCue[32];
  float fFogOpaqueDist;
  float fFogOpaqueDistSqrd;
  int remapCount;
  int currentPlayerClone;
  trigger_info_t pendingTriggerList[256];
  trigger_info_t currentTriggerList[256];
  int pendingTriggerListSize;
  int currentTriggerListSize;
  int finished;
  int bPlayerIgnoreRadiusDamage;
  int bPlayerIgnoreRadiusDamageLatched;
  int registerWeapons;
  int bRegisterItems;
  int currentEntityThink;
  void *openScriptIOFileHandles[1];
  char *openScriptIOFileBuffers[1];
};
#pragma pack(pop)

/* 351 */
typedef unsigned int scr_entref_t;

/* 352 */
#pragma pack(push, 8)
struct stringIndex_t
{
  __int16 emptystring;
  __int16 allies;
  __int16 axis;
  __int16 current;
  __int16 damage;
  __int16 death;
  __int16 dlight;
  __int16 done;
  __int16 empty;
  __int16 entity;
  __int16 failed;
  __int16 fraction;
  __int16 goal;
  __int16 grenade;
  __int16 info_notnull;
  __int16 invisible;
  __int16 key1;
  __int16 key2;
  __int16 killanimscript;
  __int16 left;
  __int16 movedone;
  __int16 noclass;
  __int16 normal;
  __int16 pistol;
  __int16 plane_waypoint;
  __int16 player;
  __int16 position;
  __int16 primary;
  __int16 primaryb;
  __int16 prone;
  __int16 right;
  __int16 rocket;
  __int16 rotatedone;
  __int16 script_brushmodel;
  __int16 script_model;
  __int16 script_origin;
  __int16 spectator;
  __int16 stand;
  __int16 surfacetype;
  __int16 target_script_trigger;
  __int16 tempEntity;
  __int16 touch;
  __int16 trigger;
  __int16 trigger_use;
  __int16 trigger_use_touch;
  __int16 trigger_damage;
  __int16 trigger_lookat;
  __int16 truck_cam;
  __int16 worldspawn;
  __int16 binocular_enter;
  __int16 binocular_exit;
  __int16 binocular_fire;
  __int16 binocular_release;
  __int16 binocular_drop;
  __int16 begin;
  __int16 intermission;
  __int16 menuresponse;
  __int16 playing;
  __int16 none;
  __int16 dead;
  __int16 auto_change;
  __int16 manual_change;
  __int16 freelook;
  __int16 call_vote;
  __int16 vote;
  __int16 snd_enveffectsprio_level;
  __int16 snd_enveffectsprio_shellshock;
  __int16 snd_channelvolprio_holdbreath;
  __int16 snd_channelvolprio_pain;
  __int16 snd_channelvolprio_shellshock;
  __int16 tag_flash;
  __int16 tag_flash_11;
  __int16 tag_flash_2;
  __int16 tag_flash_22;
  __int16 tag_brass;
  __int16 j_head;
  __int16 tag_weapon;
  __int16 tag_player;
  __int16 tag_camera;
  __int16 tag_aim;
  __int16 tag_aim_animated;
  __int16 tag_origin;
  __int16 tag_butt;
  __int16 tag_weapon_right;
  __int16 back_low;
  __int16 back_mid;
  __int16 back_up;
  __int16 neck;
  __int16 head;
  __int16 pelvis;
};
#pragma pack(pop)

/* 355 */
#pragma pack(push, 8)
struct svEntity_s
{
  u_int16_t worldSector;
  u_int16_t nextEntityInWorldSector;
  archivedEntity_s baseline;
  int numClusters;
  int clusternums[16];
  int lastCluster;
  int linkcontents;
  float linkmin[2];
  float linkmax[2];
};
#pragma pack(pop)

/* 356 */
#pragma pack(push, 8)
struct server_t
{
  int state;
  int restarting;
  int start_frameTime;
  int checksumFeed;
  int timeResidual;
  int unk;
  struct cmodel_s *models[256];
  char *configstrings[2048];
  svEntity_s svEntities[1024];
  char *entityParsePoint;
  gentity_s *gentities;
  int gentitySize;
  int num_entities;
  playerState_s *gameClients;
  int gameClientSize;
  int skelTimeStamp;
  int skelMemPos;
  int bpsWindow[20];
  int bpsWindowSteps;
  int bpsTotalBytes;
  int bpsMaxBytes;
  int ubpsWindow[20];
  int ubpsTotalBytes;
  int ubpsMaxBytes;
  float ucompAve;
  int ucompNum;
  char gametype[64];
};
#pragma pack(pop)

/* 393 */
#pragma pack(push, 8)
struct cLeaf_s
{
  u_int16_t firstCollAabbIndex;
  u_int16_t collAabbCount;
  int brushContents;
  int terrainContents;
  vec3_t mins;
  vec3_t maxs;
  int leafBrushNode;
  int16_t cluster;
  int16_t pad;
};
#pragma pack(pop)

/* 402 */
#pragma pack(push, 8)
struct cmodel_s
{
  vec3_t mins;
  vec3_t maxs;
  float radius;
  cLeaf_s leaf;
};
#pragma pack(pop)

/* 357 */
#pragma pack(push, 8)
struct VariableStackBuffer
{
  const char *pos;
  u_int16_t size;
  u_int16_t bufLen;
  u_int16_t localId;
  char time;
  char buf[1];
};
#pragma pack(pop)

/* 358 */
#pragma pack(push, 8)
union VariableUnion
{
  int intValue;
  float floatValue;
  unsigned int stringValue;
  const float *vectorValue;
  const char *codePosValue;
  unsigned int pointerValue;
  struct VariableStackBuffer *stackValue;
  unsigned int entityOffset;
};
#pragma pack(pop)

/* 359 */
#pragma pack(push, 8)
union ObjectInfo_u
{
  u_int16_t size;
  u_int16_t entnum;
  u_int16_t nextEntId;
  u_int16_t self;
};
#pragma pack(pop)

/* 360 */
#pragma pack(push, 8)
struct VarObjectInfo
{
  u_int16_t refCount;
  union ObjectInfo_u u;
};
#pragma pack(pop)

/* 361 */
#pragma pack(push, 8)
struct VariableValueInternal_u
{
  u_int16_t next;
  union VariableUnion u;
  struct VarObjectInfo o;
};
#pragma pack(pop)

/* 362 */
#pragma pack(push, 8)
struct VariableValueInternal_w
{
  unsigned int status;
  unsigned int type;
  unsigned int name;
  unsigned int classnum;
  unsigned int notifyName;
  unsigned int waitTime;
  unsigned int parentLocalId;
};
#pragma pack(pop)

/* 363 */
#pragma pack(push, 8)
struct VariableValueInternal_v
{
  u_int16_t next;
  u_int16_t index;
};
#pragma pack(pop)

/* 364 */
#pragma pack(push, 8)
struct VariableValue_s
{
  union VariableUnion u;
  int type;
};
#pragma pack(pop)

/* 365 */
#pragma pack(push, 8)
struct Variable_u
{
  u_int16_t prev;
  u_int16_t prevSibling;
};
#pragma pack(pop)

/* 366 */
#pragma pack(push, 8)
struct Variable
{
  u_int16_t id;
  Variable_u u;
};
#pragma pack(pop)

/* 367 */
#pragma pack(push, 8)
struct VariableValueInternal
{
  struct Variable hash;
  VariableValueInternal_u u;
  VariableValueInternal_w w;
  VariableValueInternal_v v;
  u_int16_t nextSibling;
};
#pragma pack(pop)

/* 368 */
#pragma pack(push, 8)
struct function_stack_t
{
  const char *pos;
  unsigned int localId;
  unsigned int localVarCount;
  VariableValue_s *top;
  VariableValue_s *startTop;
};
#pragma pack(pop)

/* 369 */
#pragma pack(push, 8)
struct function_frame_t
{
  struct function_stack_t fs;
  int topType;
};
#pragma pack(pop)

/* 370 */
#pragma pack(push, 8)
struct scrVmPub_t
{
  unsigned int *localVars;
  VariableValue_s *maxstack;
  int function_count;
  struct function_frame_t *function_frame;
  VariableValue_s *top;
  byte debugCode;
  byte abort_on_error;
  byte terminal_error;
  byte pad;
  unsigned int inparamcount;
  unsigned int outparamcount;
  struct function_frame_t function_frame_start[32];
  VariableValue_s stack[2048];
};
#pragma pack(pop)

/* 371 */
#pragma pack(push, 8)
struct dmaterial_t
{
  char material[64];
  int surfaceFlags;
  int contentFlags;
};
#pragma pack(pop)

/* 372 */
#pragma pack(push, 8)
struct gitem_s
{
  char *classname;
  char *pickup_sound;
  char *world_model;
  int giTag;
  char *icon;
  char *display_name;
  int quantity;
  int giType;
  int giAmmoIndex;
  int giClipIndex;
  int giSharedAmmoCapIndex;
};
#pragma pack(pop)

/* 373 */
#pragma pack(push, 8)
struct XBoneInfo_s
{
  float bounds[2][3];
  float offset[3];
  float radiusSquared;
};
#pragma pack(pop)

/* 374 */
#pragma pack(push, 8)
struct XModelCollSurf_s
{
  float mins[3];
  float maxs[3];
  int boneIdx;
  int contents;
  int surfFlags;
};
#pragma pack(pop)

/* 375 */
#pragma pack(push, 8)
struct XModelHighMipBounds_s
{
  float mins[3];
  float maxs[3];
};
#pragma pack(pop)

/* 376 */
#pragma pack(push, 8)
struct XModelStreamInfo_s
{
  XModelHighMipBounds_s *highMipBounds;
};
#pragma pack(pop)

/* 378 */
#pragma pack(push, 8)
struct XModelLodInfo_s
{
  float dist;
  unsigned __int16 numsurfs;
  unsigned __int16 surfIndex;
};
#pragma pack(pop)

/* 377 */
#pragma pack(push, 8)
struct XModel
{
  char numBones;
  char numRootBones;
  char numsurfs;
  char field_7;
  XModelLodInfo_s lodInfo[4];
  u_int16_t *boneNames;
  char *parentList;
  byte unk[40];
  XModelCollSurf_s *collSurfs;
  int numCollSurfs;
  int contents;
  XBoneInfo_s *boneInfo;
  vec3_t mins;
  vec3_t maxs;
  __int16 numLods;
  __int16 collLod;
  XModelStreamInfo_s streamInfo;
  int memUsage;
  const char *name;
  char flags;
  char bad;
};
#pragma pack(pop)

/* 379 */
typedef void (*xcommand_t)(void);

/* 380 */
#pragma pack(push, 8)
struct cmd_function_s
{
  struct cmd_function_s *next;
  char *name;
  xcommand_t function;
};
#pragma pack(pop)

/* 381 */
#pragma pack(push, 8)
struct fileInPack_s
{
  unsigned int pos;
  char *name;
  struct fileInPack_s *next;
};
#pragma pack(pop)

/* 382 */
#pragma pack(push, 8)
struct pack_t
{
  char pakFilename[256];
  char pakBasename[256];
  char pakGamename[256];
  voidp handle;
  int checksum;
  int pure_checksum;
  int hasOpenFile;
  int numfiles;
  int referenced;
  int hashSize;
  fileInPack_s **hashTable;
  fileInPack_s *buildBuffer;
};
#pragma pack(pop)

/* 383 */
#pragma pack(push, 8)
struct directory_t
{
  char path[256];
  char gamedir[256];
};
#pragma pack(pop)

/* 384 */
#pragma pack(push, 8)
struct searchpath_t
{
  struct searchpath_s *next;
  pack_t *pack;
  directory_t *dir;
  int localized;
  int langIndex;
};
#pragma pack(pop)

/* 385 */
#pragma pack(push, 8)
struct DObjSkeletonPartMatrix_s
{
  float p1[4];
  float p2[4];
};
#pragma pack(pop)

/* 386 */
#pragma pack(push, 8)
struct DSkelPartBits_s
{
  int anim[4];
  int control[4];
  int skel[4];
};
#pragma pack(pop)

/* 387 */
#pragma pack(push, 8)
struct DSkel_s
{
  DSkelPartBits_s *partBits;
  int timeStamp;
  DObjSkeletonPartMatrix_s *mat;
};
#pragma pack(pop)

/* 388 */
#pragma pack(push, 8)
struct DObj_s
{
  int *tree;
  DSkel_s skel;
  unsigned __int16 duplicateParts;
  int unk2;
  byte numModels;
  byte numBones;
  byte duplicatePartsSize;
  byte pad;
  XModel *models;
};
#pragma pack(pop)

/* 389 */
#pragma pack(push, 8)
struct cStaticModel_s
{
  u_int16_t writable;
  XModel *xmodel;
  vec3_t origin;
  vec3_t invScaledAxis[3];
  vec3_t absmin;
  vec3_t absmax;
};
#pragma pack(pop)

/* 390 */
#pragma pack(push, 8)
struct cplane_s
{
  vec3_t normal;
  float dist;
  byte type;
  byte signbits;
  byte pad[2];
};
#pragma pack(pop)

/* 391 */
#pragma pack(push, 8)
struct cbrushside_s
{
  cplane_s *plane;
  unsigned int materialNum;
};
#pragma pack(pop)

/* 392 */
#pragma pack(push, 8)
struct cNode_s
{
  cplane_s *plane;
  int16_t children[2];
};
#pragma pack(pop)

/* 394 */
#pragma pack(push, 8)
struct cLeafBrushNodeLeaf_s
{
  u_int16_t *brushes;
};
#pragma pack(pop)

/* 395 */
#pragma pack(push, 8)
struct cLeafBrushNodeChildren_s
{
  float dist;
  float range;
  u_int16_t childOffset[2];
};
#pragma pack(pop)

/* 396 */
#pragma pack(push, 8)
struct cLeafBrushNodeData_s
{
  cLeafBrushNodeLeaf_s leaf;
  cLeafBrushNodeChildren_s children;
};
#pragma pack(pop)

/* 397 */
#pragma pack(push, 2)
struct cLeafBrushNode_s
{
  byte axis;
  u_int16_t leafBrushCount;
  int contents;
  cLeafBrushNodeData_s data;
};
#pragma pack(pop)

/* 398 */
#pragma pack(push, 8)
struct CollisionBorder
{
  float distEq[3];
  float zBase;
  float zSlope;
  float start;
  float length;
};
#pragma pack(pop)

/* 399 */
#pragma pack(push, 8)
struct CollisionPartition
{
  char triCount;
  char borderCount;
  int firstTri;
  CollisionBorder *borders;
};
#pragma pack(pop)

/* 400 */
#pragma pack(push, 8)
struct CollisionAabbTreeIndex_s
{
  int firstChildIndex;
  int partitionIndex;
};
#pragma pack(pop)

/* 401 */
#pragma pack(push, 8)
struct CollisionAabbTree_s
{
  float origin[3];
  float halfSize[3];
  u_int16_t materialIndex;
  u_int16_t childCount;
  CollisionAabbTreeIndex_s u;
};
#pragma pack(pop)

/* 403 */
struct __attribute__((aligned(16))) cbrush_s
{
  float mins[3];
  int contents;
  float maxs[3];
  unsigned int numsides;
  cbrushside_s *sides;
  int16_t axialMaterialNum[2][3];
};

/* 404 */
#pragma pack(push, 8)
struct CollisionEdge_s
{
  float position[3];
  float normal[3][3];
};
#pragma pack(pop)

/* 405 */
#pragma pack(push, 8)
struct CollisionTriangle_s
{
  float normal[3];
  float distance;
  float unknown[8];
  unsigned int vertex_id[3];
  int edge_id[3];
};
#pragma pack(pop)

/* 406 */
#pragma pack(push, 8)
struct clipMap_s
{
  const char *name;
  unsigned int numStaticModels;
  cStaticModel_s *staticModelList;
  unsigned int numMaterials;
  dmaterial_t *materials;
  unsigned int numBrushSides;
  cbrushside_s *brushsides;
  unsigned int numNodes;
  cNode_s *nodes;
  unsigned int numLeafs;
  cLeaf_s *leafs;
  unsigned int leafbrushNodesCount;
  cLeafBrushNode_s *leafbrushNodes;
  unsigned int numLeafBrushes;
  u_int16_t *leafbrushes;
  unsigned int numLeafSurfaces;
  unsigned int *leafsurfaces;
  unsigned int vertCount;
  float (*verts)[3];
  unsigned int edgeCount;
  CollisionEdge_s *edges;
  int triCount;
  CollisionTriangle_s *triIndices;
  int borderCount;
  CollisionBorder *borders;
  int partitionCount;
  CollisionPartition *partitions;
  int aabbTreeCount;
  CollisionAabbTree_s *aabbTrees;
  unsigned int numSubModels;
  cmodel_s *cmodels;
  u_int16_t numBrushes;
  cbrush_s *brushes;
  int numClusters;
  int clusterBytes;
  byte *visibility;
  int vised;
  int numEntityChars;
  char *entityString;
  cbrush_s *box_brush;
  cmodel_s box_model;
  u_int16_t dynEntCount[2];
  void *dynEntDefList[2];
  void *dynEntPoseList[2];
  void *dynEntClientList[2];
  void *dynEntCollList[2];
  unsigned int checksum;
};
#pragma pack(pop)

/* 407 */
typedef const char FxEffectDef_t;

/* 408 */
typedef const char snd_alias_list_t;

/* 409 */
typedef const char Material_t;

/* 410 */
#pragma pack(push, 8)
struct WeaponDef_s
{
  const char *szInternalName;
  const char *szDisplayName;
  const char *szOverlayName;
  const char *szViewModelName;
  const char *szHandModelName;
  int unknown;
  const char *szXAnims[22];
  const char *szModeName;
  int playerAnimType;
  int weapType;
  int weapClass;
  int impactType;
  int inventoryType;
  int offhandClass;
  int stance;
  FxEffectDef_t *viewFlashEffect;
  FxEffectDef_t *worldFlashEffect;
  snd_alias_list_t *pickupSound;
  snd_alias_list_t *ammoPickupSound;
  snd_alias_list_t *projectileSound;
  snd_alias_list_t *pullbackSound;
  snd_alias_list_t *fireSound;
  snd_alias_list_t *fireSoundPlayer;
  snd_alias_list_t *fireLoopSound;
  snd_alias_list_t *fireLoopSoundPlayer;
  snd_alias_list_t *fireStopSound;
  snd_alias_list_t *fireStopSoundPlayer;
  snd_alias_list_t *fireLastSound;
  snd_alias_list_t *fireLastSoundPlayer;
  snd_alias_list_t *meleeSwipeSound;
  snd_alias_list_t *rechamberSound;
  snd_alias_list_t *rechamberSoundPlayer;
  snd_alias_list_t *reloadSound;
  snd_alias_list_t *reloadSoundPlayer;
  snd_alias_list_t *reloadEmptySound;
  snd_alias_list_t *reloadEmptySoundPlayer;
  snd_alias_list_t *reloadStartSound;
  snd_alias_list_t *reloadStartSoundPlayer;
  snd_alias_list_t *reloadEndSound;
  snd_alias_list_t *reloadEndSoundPlayer;
  snd_alias_list_t *altSwitchSound;
  snd_alias_list_t *raiseSound;
  snd_alias_list_t *putawaySound;
  snd_alias_list_t *noteTrackSoundA;
  snd_alias_list_t *noteTrackSoundB;
  snd_alias_list_t *noteTrackSoundC;
  snd_alias_list_t *noteTrackSoundD;
  FxEffectDef_t *shellEjectEffect;
  FxEffectDef_t *lastShotEjectEffect;
  Material_t *reticleCenter;
  Material_t *reticleSide;
  int iReticleCenterSize;
  int iReticleSideSize;
  int iReticleMinOfs;
  float vStandMove[3];
  float vStandRot[3];
  float vDuckedOfs[3];
  float vDuckedMove[3];
  float vDuckedRot[3];
  float vProneOfs[3];
  float vProneMove[3];
  float vProneRot[3];
  float fPosMoveRate;
  float fPosProneMoveRate;
  float fStandMoveMinSpeed;
  float fDuckedMoveMinSpeed;
  float fProneMoveMinSpeed;
  float fPosRotRate;
  float fPosProneRotRate;
  float fStandRotMinSpeed;
  float fDuckedRotMinSpeed;
  float fProneRotMinSpeed;
  const char *worldModel;
  Material_t *hudIcon;
  Material_t *modeIcon;
  int iStartAmmo;
  const char *szAmmoName;
  int iAmmoIndex;
  const char *szClipName;
  int iClipIndex;
  int iMaxAmmo;
  int iClipSize;
  int shotCount;
  const char *szSharedAmmoCapName;
  int iSharedAmmoCapIndex;
  int iSharedAmmoCap;
  int damage;
  int playerDamage;
  int iMeleeDamage;
  int iDamageType;
  int iFireDelay;
  int iMeleeDelay;
  int iFireTime;
  int iRechamberTime;
  int iRechamberBoltTime;
  int iHoldFireTime;
  int iMeleeTime;
  int iReloadTime;
  int iReloadEmptyTime;
  int iReloadAddTime;
  int iReloadStartTime;
  int iReloadStartAddTime;
  int iReloadEndTime;
  int iDropTime;
  int iRaiseTime;
  int iAltDropTime;
  int iAltRaiseTime;
  int quickDropTime;
  int quickRaiseTime;
  int fuseTime;
  float autoAimRange;
  float aimAssistRange;
  float aimAssistRangeAds;
  float aimPadding;
  float enemyCrosshairRange;
  int crosshairColorChange;
  float moveSpeedScale;
  float fAdsZoomFov;
  float fAdsZoomInFrac;
  float fAdsZoomOutFrac;
  Material_t *overlayMaterial;
  int overlayReticle;
  float overlayWidth;
  float overlayHeight;
  float fAdsBobFactor;
  float fAdsViewBobMult;
  float fHipSpreadStandMin;
  float fHipSpreadDuckedMin;
  float fHipSpreadProneMin;
  float hipSpreadStandMax;
  float hipSpreadDuckedMax;
  float hipSpreadProneMax;
  float fHipSpreadDecayRate;
  float fHipSpreadFireAdd;
  float fHipSpreadTurnAdd;
  float fHipSpreadMoveAdd;
  float fHipSpreadDuckedDecay;
  float fHipSpreadProneDecay;
  float fHipReticleSidePos;
  int iAdsTransInTime;
  int iAdsTransOutTime;
  float fAdsIdleAmount;
  float fHipIdleAmount;
  float adsIdleSpeed;
  float hipIdleSpeed;
  float fIdleCrouchFactor;
  float fIdleProneFactor;
  float fGunMaxPitch;
  float fGunMaxYaw;
  float swayMaxAngle;
  float swayLerpSpeed;
  float swayPitchScale;
  float swayYawScale;
  float swayHorizScale;
  float swayVertScale;
  float swayShellShockScale;
  float adsSwayMaxAngle;
  float adsSwayLerpSpeed;
  float adsSwayPitchScale;
  float adsSwayYawScale;
  float adsSwayHorizScale;
  float adsSwayVertScale;
  int bRifleBullet;
  int armorPiercing;
  int semiAuto;
  int bBoltAction;
  int aimDownSight;
  int bRechamberWhileAds;
  float adsViewErrorMin;
  float adsViewErrorMax;
  int bCookOffHold;
  int bClipOnly;
  int cancelAutoHolsterWhenEmpty;
  int suppressAmmoReserveDisplay;
  Material_t *killIcon;
  int killIconRatio;
  int flipKillIcon;
  int bNoPartialReload;
  int bSegmentedReload;
  int iReloadAmmoAdd;
  int iReloadStartAdd;
  const char *szAltWeaponName;
  uint altWeaponIndex;
  int iDropAmmoMin;
  int iDropAmmoMax;
  int iExplosionRadius;
  int iExplosionInnerDamage;
  int iExplosionOuterDamage;
  int iProjectileSpeed;
  int iProjectileSpeedUp;
  const char *projectileModel;
  int projExplosion;
  FxEffectDef_t *projExplosionEffect;
  snd_alias_list_t *projExplosionSound;
  int bProjImpactExplode;
  float parallelBounce[23];
  float perpendicularBounce[23];
  FxEffectDef_t *projTrailEffect;
  int unknown2[4];
  float fAdsAimPitch;
  float fAdsCrosshairInFrac;
  float fAdsCrosshairOutFrac;
  int adsGunKickReducedKickBullets;
  float adsGunKickReducedKickPercent;
  float fAdsGunKickPitchMin;
  float fAdsGunKickPitchMax;
  float fAdsGunKickYawMin;
  float fAdsGunKickYawMax;
  float fAdsGunKickAccel;
  float fAdsGunKickSpeedMax;
  float fAdsGunKickSpeedDecay;
  float fAdsGunKickStaticDecay;
  float fAdsViewKickPitchMin;
  float fAdsViewKickPitchMax;
  float fAdsViewKickYawMin;
  float fAdsViewKickYawMax;
  float fAdsViewKickCenterSpeed;
  float fAdsViewScatterMin;
  float fAdsViewScatterMax;
  float fAdsSpread;
  int hipGunKickReducedKickBullets;
  float hipGunKickReducedKickPercent;
  float fHipGunKickPitchMin;
  float fHipGunKickPitchMax;
  float fHipGunKickYawMin;
  float fHipGunKickYawMax;
  float fHipGunKickAccel;
  float fHipGunKickSpeedMax;
  float fHipGunKickSpeedDecay;
  float fHipGunKickStaticDecay;
  float fHipViewKickPitchMin;
  float fHipViewKickPitchMax;
  float fHipViewKickYawMin;
  float fHipViewKickYawMax;
  float fHipViewKickCenterSpeed;
  float fHipViewScatterMin;
  float fHipViewScatterMax;
  float fightDist;
  float maxDist;
  const char *aiVsAiAccuracyGraph;
  const char *aiVsPlayerAccuracyGraph;
  int accuracyGraphKnotCount[2];
  int originalAccuracyGraphKnotCount[2];
  int iPositionReloadTransTime;
  float leftArc;
  float rightArc;
  float topArc;
  float bottomArc;
  float accuracy;
  float aiSpread;
  float playerSpread;
  int minVertTurnSpeed;
  int minHorTurnSpeed;
  int maxVertTurnSpeed;
  int maxHorTurnSpeed;
  float pitchConvergenceTime;
  float yawConvergenceTime;
  float suppressTime;
  float maxRange;
  float fAnimHorRotateInc;
  float fPlayerPositionDist;
  const char *szUseHintString;
  const char *dropHintString;
  int iUseHintStringIndex;
  int dropHintStringIndex;
  float horizViewJitter;
  float vertViewJitter;
  const char *szScript;
  float fOOPosAnimLength[2];
  int minDamage;
  int minPlayerDamage;
  float fMaxDamageRange;
  float fMinDamageRange;
  int unknown5[4];
  float locationDamageMultipliers[19];
  const char *fireRumble;
  const char *meleeImpactRumble;
};
#pragma pack(pop)

/* 411 */
struct __attribute__((aligned(8))) MemoryNode
{
  uint16_t prev;
  uint16_t next;
};

/* 412 */
struct __attribute__((aligned(128))) scrMemTreeGlob_s
{
  MemoryNode nodes[65536];
  char leftBits[256];
  char numBits[256];
  char logBits[256];
  uint16_t head[17];
  int totalAlloc;
  int totalAllocBuckets;
};

/* 413 */
#pragma pack(push, 8)
struct client_fields_s
{
  const char *name;
  int ofs;
  int type;
  void (__cdecl *setter)(gclient_s *, struct client_fields_s *);
  void (__cdecl *getter)(gclient_s *, struct client_fields_s *);
};
#pragma pack(pop)

/* 414 */
#pragma pack(push, 8)
struct game_hudelem_s
{
  struct hudelem_s elem;
  int clientNum;
  int team;
  int archived;
};
#pragma pack(pop)

/* 415 */
#pragma pack(push, 8)
struct node_t
{
  struct nodetype *left;
  struct nodetype *right;
  struct nodetype *parent;
  struct nodetype *next;
  struct nodetype *prev;
  struct nodetype **head;
  int weight;
  int symbol;
};
#pragma pack(pop)

/* 416 */
#pragma pack(push, 8)
struct huff_t
{
  int blocNode;
  int blocPtrs;
  node_t *tree;
  node_t *lhead;
  node_t *ltail;
  node_t *loc[257];
  node_t **freelist;
  node_t nodeList[768];
  node_t *nodePtrs[768];
};
#pragma pack(pop)

/* 417 */
#pragma pack(push, 8)
struct huffman_t
{
  huff_t compressor;
  huff_t decompressor;
};
#pragma pack(pop)

/* 418 */
#pragma pack(push, 8)
struct sysEvent_t
{
  int evTime;
  int evType;
  int evValue;
  int evValue2;
  int evPtrLength;
  void *evPtr;
};
#pragma pack(pop)

/* 419 */
#pragma pack(push, 8)
struct weapSlot_t
{
  byte slot_none;
  byte slot_primary;
  byte slot_primaryb;
  byte pad;
};
#pragma pack(pop)

/* 420 */
union __attribute__((aligned(16))) __m128
{
  float f32[4];
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 421 */
#pragma pack(push, 8)
struct bgs_s
{
  byte animScriptData[736200];
  int multiplayer;
  int root;
  int torso;
  int legs;
  int turning;
  int turnAnimEndTime;
  int frametime;
  float angle;
  void *(__cdecl *AllocXAnim)(int);
  struct XModel *(__cdecl *GetXModel)(const char *);
  void (__cdecl *CreateDObj)(struct DObjModel_s *, u_int16_t, struct XAnimTree_s *, int, int, struct clientInfo_t *);
  u_int16_t (__cdecl *AttachWeapon)(struct DObjModel_s *, u_int16_t, struct clientInfo_t *);
  struct DObj_s *(__cdecl *GetDObj)(int, int);
};
#pragma pack(pop)

/* 429 */
#pragma pack(push, 8)
struct lerpFrame_t
{
  float yawAngle;
  int yawing;
  float pitchAngle;
  int pitching;
  int animationNumber;
  struct animation_s *animation;
  int animationTime;
  vec3_t oldFramePos;
  float animSpeedScale;
  int oldFrameSnapshotTime;
};
#pragma pack(pop)

/* 428 */
#pragma pack(push, 8)
struct clientControllers_s
{
  vec3_t angles[6];
  vec3_t tag_origin_angles;
  vec3_t tag_origin_offset;
};
#pragma pack(pop)

/* 430 */
#pragma pack(push, 8)
struct clientInfo_t
{
  int infoValid;
  int nextValid;
  int clientNum;
  char name[16];
  int team;
  int oldteam;
  int rank;
  int unk1;
  int unk2;
  int score;
  int location;
  int health;
  char model[64];
  char attachModelNames[6][64];
  char attachTagNames[6][64];
  struct lerpFrame_t legs;
  struct lerpFrame_t torso;
  float lerpMoveDir;
  float lerpLean;
  float playerAngles[3];
  int leftHandGun;
  int dobjDirty;
  struct clientControllers_s control;
  unsigned int clientConditions[10][2];
  struct XAnimTree_s *pXAnimTree;
  int iDObjWeapon;
  char weaponModel;
  char pad[3];
  int stanceTransitionTime;
  int turnAnimEndTime;
  char turnAnimType;
  char pad2[3];
  int attachedVehEntNum;
  int attachedVehSlotIndex;
  byte hideWeapon;
  byte usingKnife;
  char pad3[2];
};
#pragma pack(pop)

/* 422 */
#pragma pack(push, 8)
struct legacyHacks_s
{
  byte unknown[92];
  char mapname[64];
  char gametype[64];
};
#pragma pack(pop)

/* 423 */
#pragma pack(push, 8)
struct areaParms_t
{
  const float *mins;
  const float *maxs;
  int *list;
  int count;
  int maxcount;
  int contentmask;
};
#pragma pack(pop)

/* 424 */
typedef void (__cdecl *xfunction_t)();

/* 425 */
typedef void (__cdecl *xmethod_t)(scr_entref_t);

/* 426 */
#pragma pack(push, 8)
struct scr_function_s
{
  const char *name;
  xfunction_t call;
  int developer;
};
#pragma pack(pop)

/* 427 */
#pragma pack(push, 8)
struct scr_method_s
{
  const char *name;
  xmethod_t call;
  int developer;
};
#pragma pack(pop)

/* 431 */
#pragma pack(push, 8)
struct gameTypeScript_t
{
  char pszScript[64];
  char pszName[64];
  int bTeamBased;
};
#pragma pack(pop)

/* 432 */
#pragma pack(push, 8)
struct scr_gametype_data_t
{
  int main;
  int startupgametype;
  int playerconnect;
  int playerdisconnect;
  int playerdamage;
  int playerkilled;
  int votecalled;
  int playervote;
  int iNumGameTypes;
  struct gameTypeScript_t list[32];
};
#pragma pack(pop)

/* 433 */
#pragma pack(push, 4)
struct corpseInfo_t
{
  struct XAnimTree_s *tree;
  struct clientInfo_t ci;
  int entnum;
  int time;
  byte falling;
  byte pad[3];
};
#pragma pack(pop)

/* 434 */
#pragma pack(push, 8)
struct scr_data_t
{
  int levelscript;
  int gametypescript;
  struct scr_gametype_data_t gametype;
  int delete;
  int initstructs;
  int createstruct;
  void *playerCorpseInfo;
};
#pragma pack(pop)

/* 435 */
union HashUnion
{
  u_int16_t prev;
  u_int16_t str;
};

/* 436 */
struct HashEntry
{
  u_int16_t status_next;
  HashUnion hash;
};

/* 437 */
struct __attribute__((aligned(128))) scrStringGlob_s
{
  HashEntry hashTable[16384];
  bool inited;
  HashEntry *nextFreeEntry;
};

/* 438 */
typedef unsigned int clipHandle_t;

/* 439 */
#pragma pack(push, 8)
struct TraceCheckCount
{
  int global;
  int *edges;
  int *verts;
  int *partitions;
};
#pragma pack(pop)

/* 440 */
#pragma pack(push, 8)
struct TraceThreadInfo
{
  int global;
  int *edges;
  int *verts;
  int *partitions;
  struct cbrush_s *box_brush;
  struct cmodel_s *box_model;
};
#pragma pack(pop)

/* 441 */
#pragma pack(push, 8)
struct entityHandler_t
{
  void (__cdecl *think)(struct gentity_s *);
  void (__cdecl *reached)(struct gentity_s *);
  void (__cdecl *blocked)(struct gentity_s *, struct gentity_s *);
  void (__cdecl *touch)(struct gentity_s *, struct gentity_s *, int);
  void (__cdecl *use)(struct gentity_s *, struct gentity_s *, struct gentity_s *);
  void (__cdecl *pain)(struct gentity_s *, struct gentity_s *, int, const float *, const int, const float *, enum hitLocation_t, const int);
  void (__cdecl *die)(struct gentity_s *, struct gentity_s *, struct gentity_s *, int, int, const int, const float *, enum hitLocation_t, int);
  void (__cdecl *controller)(struct gentity_s *, int *);
  int methodOfDeath;
  int splashMethodOfDeath;
};
#pragma pack(pop)

/* 448 */
enum MissileStage
{
  MISSILESTAGE_SOFTLAUNCH = 0x0,
  MISSILESTAGE_ASCENT = 0x1,
  MISSILESTAGE_DESCENT = 0x2,
};

/* 449 */
enum MissileFlightMode
{
  MISSILEFLIGHTMODE_TOP = 0x0,
  MISSILEFLIGHTMODE_DIRECT = 0x1,
};

/* 451 */
#pragma pack(push, 2)
struct tag_t
{
  u_int16_t name;
  u_int16_t index;
};
#pragma pack(pop)

/* 453 */
#pragma pack(push, 8)
struct va_info_t
{
  char va_string[2][1024];
  int index;
};
#pragma pack(pop)

/* 454 */
#pragma pack(push, 8)
struct hunkUsed_t
{
  int permanent;
  int temp;
};
#pragma pack(pop)

/* 455 */
#pragma pack(push, 8)
struct scrVmGlob_t
{
  VariableValue_s eval_stack[2];
  const char *dialog_error_message;
  int loading;
  unsigned int localVarsStack[2048];
};
#pragma pack(pop)

/* 456 */
struct __attribute__((aligned(64))) scrVarGlob_t
{
  VariableValueInternal *variableList;
};

/* 457 */
#pragma pack(push, 8)
struct scr_animtree_t
{
  struct XAnim_s *anims;
};
#pragma pack(pop)

/* 458 */
#pragma pack(push, 8)
struct scrAnimPub_t
{
  unsigned int animtrees;
  unsigned int animtree_node;
  unsigned int animTreeNames;
  struct scr_animtree_t xanim_lookup[2][128];
  unsigned int xanim_num[2];
  unsigned int animTreeIndex;
  int animtree_loading;
};
#pragma pack(pop)

/* 459 */
#pragma pack(push, 1)
struct scrCompilePub_t
{
  int value_count;
  int far_function_count;
  unsigned int loadedscripts;
  unsigned int scriptsPos;
  unsigned int builtinFunc;
  unsigned int builtinMeth;
  uint16_t *canonicalStrings;
  const char *in_ptr;
  const char *parseBuf;
  byte script_loading;
  byte allowedBreakpoint;
  int16_t pad;
  int developer_statement;
  char *opcodePos;
  unsigned int programLen;
  int func_table_size;
  int func_table[1024];
};
#pragma pack(pop)

/* 460 */
#pragma pack(push, 8)
struct SourceBufferInfo
{
  const char *codePos;
  char *buf;
  const char *sourceBuf;
  int len;
  int sortedIndex;
  bool archive;
  byte pad[3];
};
#pragma pack(pop)

/* 461 */
#pragma pack(push, 8)
struct scrParserPub_t
{
  struct SourceBufferInfo *sourceBufferLookup;
  unsigned int sourceBufferLookupLen;
  const char *scriptfilename;
  const char *sourceBuf;
};
#pragma pack(pop)

/* 462 */
#pragma pack(push, 8)
struct SaveSourceBufferInfo
{
  char *sourceBuf;
  int len;
};
#pragma pack(pop)

/* 463 */
#pragma pack(push, 8)
struct SourceLookup
{
  unsigned int sourcePos;
  int type;
};
#pragma pack(pop)

/* 464 */
#pragma pack(push, 8)
struct OpcodeLookup
{
  const char *codePos;
  unsigned int sourcePosIndex;
  unsigned int sourcePosCount;
  int profileTime;
  int profileBuiltInTime;
  int profileUsage;
};
#pragma pack(pop)

/* 465 */
#pragma pack(push, 8)
struct scrParserGlob_t
{
  struct OpcodeLookup *opcodeLookup;
  unsigned int opcodeLookupMaxLen;
  unsigned int opcodeLookupLen;
  struct SourceLookup *sourcePosLookup;
  unsigned int sourcePosLookupMaxLen;
  unsigned int sourcePosLookupLen;
  unsigned int sourceBufferLookupMaxLen;
  const char *currentCodePos;
  unsigned int currentSourcePosCount;
  struct SaveSourceBufferInfo *saveSourceBufferLookup;
  unsigned int saveSourceBufferLookupLen;
  int delayedSourceIndex;
  int threadStartSourceIndex;
};
#pragma pack(pop)

/* 466 */
struct RefStruct
{
  unsigned __int32 refCount : 16;
  unsigned __int32 user : 8;
  unsigned __int32 byteLen : 8;
};

/* 467 */
union RefUnion
{
  RefStruct params;
  volatile int data;
};

/* 468 */
#pragma pack(push, 4)
struct __attribute__((aligned(4))) RefString
{
  RefUnion ref;
  char str[1];
};
#pragma pack(pop)

/* 469 */
struct __attribute__((aligned(128))) scrMemTreePub_s
{
  RefString buckets[65536];
};

/* 470 */
typedef int qboolean;

/* 471 */
#pragma pack(push, 8)
struct clReliableCommands_t
{
  char command[1024];
};
#pragma pack(pop)

/* 472 */
typedef int fileHandle_t;

/* 473 */
#pragma pack(push, 8)
struct clientConnection_t
{
  int state;
  int net_qport;
  int clientNum;
  int lastPacketSentTime;
  int lastPacketTime;
  netadr_t serverAddress;
  int connectTime;
  int connectPacketCount;
  char serverMessage[256];
  int challenge;
  int checksumFeed;
  int reliableSequence;
  int reliableAcknowledge;
  clReliableCommands_t reliableCommands[128];
  int serverMessageSequence;
  int serverCommandSequence;
  int lastExecutedServerCommand;
  char serverCommands[128][1024];
};
#pragma pack(pop)

/* 474 */
#pragma pack(push, 8)
struct NetField
{
  char *name;
  int offset;
  int bits;
};
#pragma pack(pop)

/* 475 */
#pragma pack(push, 8)
struct snapshotInfo_s
{
  int clnum;
  struct client_s *client;
  int snapshotDeltaTime;
  byte fromBaseline;
  byte archived;
  byte pad[2];
};
#pragma pack(pop)

/* 476 */
#pragma pack(push, 8)
struct connectqueue_t
{
  int challengeslot;
  int firsttime;
  int lasttime;
  int attempts;
};
#pragma pack(pop)

/* 478 */
#pragma pack(push, 8)
struct TraceExtents
{
  vec3_t start;
  vec3_t end;
  vec3_t invDelta;
};
#pragma pack(pop)

/* 479 */
#pragma pack(push, 8)
struct IgnoreEntParams
{
  int baseEntity;
  int parentEntity;
  byte ignoreSelf;
  byte ignoreParent;
  byte ignoreSiblings;
  byte ignoreChildren;
};
#pragma pack(pop)

/* 480 */
#pragma pack(push, 8)
struct pointtrace_t
{
  TraceExtents extents;
  IgnoreEntParams *ignoreEntParams;
  int contentmask;
  int bLocational;
  char *priorityMap;
};
#pragma pack(pop)

/* 481 */
union TraceResults
{
  vec3_t normal;
};

